<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 è·¨å¹´ç››å…¸ - å¸ç‹è±ªåå®Œå…¨ä½“ V9</title>
    <style>
        /* --- å¸ç‹çº§æ ·å¼ --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Microsoft YaHei', sans-serif; 
            width: 100%; 
            height: 100%; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }
        
        #canvas-wrapper { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: radial-gradient(circle at center, #2b1d0e 0%, #000000 90%); 
            overflow: hidden; 
        }
        
        #canvas-container { 
            width: 100%; 
            height: 100%; 
            display: block; 
        }

        /* --- é¡¶éƒ¨æ§åˆ¶åŒº --- */
        #top-bar {
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 150;
            display: flex; 
            gap: 15px; 
            align-items: center;
        }

        #music-control {
            width: 44px; 
            height: 44px; 
            border-radius: 50%;
            border: 2px solid #ffd700; 
            color: #ffd700; 
            background: rgba(0,0,0,0.6);
            display: flex; 
            justify-content: center; 
            align-items: center; 
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); 
            animation: spin 8s linear infinite;
        }
        
        .paused { 
            animation-play-state: paused !important; 
            filter: grayscale(1); 
            opacity: 0.5; 
        }
        
        @keyframes spin { 
            100% { 
                transform: rotate(360deg); 
            } 
        }

        /* æš´åŠ›å¯åŠ¨æŒ‰é’® */
        #force-btn {
            background: linear-gradient(135deg, #ff0000 0%, #ff4400 100%);
            border: 2px solid #fff; 
            padding: 10px 20px; 
            border-radius: 30px;
            color: #fff; 
            font-weight: bold; 
            font-size: 0.9rem; 
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); 
            animation: pulseRed 1.5s infinite;
        }
        
        @keyframes pulseRed { 
            0% { 
                transform: scale(1); 
            } 
            50% { 
                transform: scale(1.05); 
            } 
            100% { 
                transform: scale(1); 
            } 
        }

        /* --- å®æ—¶æ—¶é’Ÿ (å¹³æ—¶æ˜¾ç¤º) --- */
        #time-panel {
            position: absolute; 
            top: 18%; 
            left: 0; 
            width: 100%; 
            text-align: center; 
            pointer-events: none; 
            z-index: 20; 
            transition: opacity 1s;
        }
        
        .main-clock {
            font-size: 15vw; 
            font-weight: 900; 
            color: #fff;
            background: linear-gradient(to bottom, #fff 40%, #ffd700 100%);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
            font-family: monospace; 
            margin: 0; 
            line-height: 1;
        }
        
        .countdown-sub { 
            font-size: 1.1rem; 
            color: #ffd700; 
            margin-top: 15px; 
            letter-spacing: 3px; 
            opacity: 0.9; 
            text-transform: uppercase; 
        }
        
        @media (min-width: 768px) { 
            .main-clock { 
                font-size: 7rem; 
            } 
        }

        /* --- æ‘„åƒå¤´å°çª— --- */
        #video-container { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            z-index: 100; 
            width: 120px; 
            height: 90px; 
            border: 2px solid rgba(255, 215, 0, 0.4); 
            border-radius: 10px; 
            overflow: hidden; 
            transform: scaleX(-1); 
            background: #000; 
            transition: 0.3s;
        }
        
        #video-container.error { 
            border-color: #f00; 
            box-shadow: 0 0 15px #f00; 
        }
        
        #video-container.minimized { 
            width: 60px; 
            height: 45px; 
            opacity: 0.7; 
        }
        
        #input-video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            opacity: 0.8; 
        }
        
        #skeleton-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }

        /* --- å¯åŠ¨å± --- */
        #start-screen { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 200; 
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%); 
            transition: opacity 0.8s;
        }
        
        #start-btn { 
            padding: 20px 60px; 
            font-size: 1.6rem; 
            font-weight: bold; 
            letter-spacing: 5px; 
            color: #4a3b00; 
            background: linear-gradient(to bottom, #fff8db, #ffd700); 
            border: none; 
            border-radius: 60px; 
            cursor: pointer; 
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); 
            margin-bottom: 20px;
        }
        
        #loading-text { 
            color: #886600; 
            font-size: 1rem; 
            letter-spacing: 2px; 
        }

        /* --- åº•éƒ¨UI --- */
        #ui-layer { 
            position: absolute; 
            bottom: 40px; 
            left: 0; 
            width: 100%; 
            z-index: 3; 
            text-align: center; 
            pointer-events: none; 
            display: none; 
        }
        
        #status-pill {
            display: inline-block; 
            background: rgba(0,0,0,0.7); 
            padding: 8px 25px; 
            border-radius: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3); 
            backdrop-filter: blur(5px); 
            pointer-events: auto; 
            cursor: pointer;
        }
        
        .instructions { 
            margin-top: 10px; 
            color: #aaa; 
            font-size: 0.9rem; 
        }
        
        .key { 
            color: #ffd700; 
            font-weight: bold; 
            margin: 0 5px; 
        }

        /* --- å…¨å±æ§åˆ¶æŒ‰é’® --- */
        .icon-btn {
            width: 44px; 
            height: 44px; 
            border-radius: 50%;
            background: rgba(0,0,0,0.5); 
            border: 1px solid rgba(255,215,0,0.5);
            color: #ffd700; 
            font-size: 20px; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            cursor: pointer; 
            backdrop-filter: blur(4px); 
            transition: 0.3s;
        }
        
        .icon-btn:hover { 
            background: rgba(255,215,0,0.2); 
            box-shadow: 0 0 15px rgba(255,215,0,0.3); 
        }

        /* --- é¡¶éƒ¨å³ä¾§æ§åˆ¶åŒº --- */
        #top-right-controls {
            position: absolute; 
            top: 20px; 
            right: 150px; 
            z-index: 150;
            display: flex; 
            gap: 10px;
        }

        /* --- å›¾ç‰‡é€‰æ‹©æŒ‡ç¤ºå™¨ --- */
        .photo-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
            pointer-events: none;
            z-index: 10;
            display: none;
        }

        /* --- å›¾ç‰‡æ”¾å¤§é¢æ¿ --- */
        #photo-detail-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 70%;
            height: 70%;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ffd700;
            border-radius: 20px;
            z-index: 300;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        #photo-detail-panel.active {
            transform: translate(-50%, -50%) scale(1);
        }

        #photo-detail-img {
            max-width: 90%;
            max-height: 80%;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
        }

        #photo-detail-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #photo-detail-title {
            color: #ffd700;
            font-size: 1.5rem;
            margin-top: 20px;
            text-align: center;
            padding: 0 20px;
        }

        /* --- åŠ è½½è¿›åº¦æ¡ --- */
        #loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(255, 215, 0, 0.2);
            margin-top: 20px;
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }

        #loading-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffd700, #ff8c00);
            transition: width 0.3s;
        }

        /* --- å“åº”å¼è°ƒæ•´ --- */
        @media screen and (max-width: 768px) {
            #top-bar {
                top: 15px;
                left: 15px;
            }
            
            #top-right-controls {
                top: 15px;
                right: 130px;
            }
            
            #video-container {
                top: 15px;
                right: 15px;
                width: 100px;
                height: 75px;
            }
            
            .main-clock {
                font-size: 12vw;
            }
            
            #photo-detail-panel {
                width: 90%;
                height: 60%;
            }
        }

        /* --- ç²’å­æ•ˆæœé®ç½© --- */
        .particle-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* --- æ‰‹åŠ¿æç¤ºåŠ¨ç”» --- */
        @keyframes gestureHint {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .gesture-hint {
            animation: gestureHint 2s infinite;
        }

        /* --- é€‰æ‹©é«˜äº®æ•ˆæœ --- */
        .selected-highlight {
            box-shadow: 0 0 30px #00ff00;
            filter: brightness(1.5);
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        { 
            "imports": { 
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
            } 
        }
    </script>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
        
        <audio id="bgm" loop preload="auto">
            <source src="./music.mp3" type="audio/mp3">
        </audio>

        <div id="top-bar">
            <div id="music-control" onclick="toggleMusic()">â™«</div>
            <button id="force-btn" onclick="forceNewYear()">ğŸš€ å¼ºåˆ¶è·¨å¹´</button>
        </div>

        <div id="top-right-controls" style="display:none;">
            <div class="icon-btn" id="fullscreen-btn" onclick="toggleFullscreen()">â›¶</div>
        </div>

        <div id="time-panel">
            <div class="main-clock" id="clock-display">00:00:00</div>
            <div class="countdown-sub" id="countdown-display">è·ç¦» 2026 ç››å…¸å¼€å¯è¿˜æœ‰ --å¤©</div>
        </div>

        <div id="video-container" onclick="toggleVideoSize()">
            <video id="input-video" autoplay playsinline muted></video>
            <canvas id="skeleton-canvas"></canvas>
        </div>

        <div id="start-screen">
            <button id="start-btn" onclick="startExperience()">è¿›å…¥ç››å…¸ç°åœº</button>
            <div id="loading-text">èµ„æºåŠ è½½ä¸­...</div>
            <div id="loading-progress">
                <div id="loading-progress-bar"></div>
            </div>
        </div>

        <div id="ui-layer">
            <div id="status-pill" onclick="setupMediaPipe()">
                <span id="status-text">ç³»ç»Ÿå°±ç»ª - ç­‰å¾…æ‰‹åŠ¿</span>
            </div>
            <div class="instructions">
                <span class="key gesture-hint">âœŠ</span> èšåˆè›‹ç³• | 
                <span class="key gesture-hint">ğŸ‘</span> æ•£å¼€ç…§ç‰‡ | 
                <span class="key gesture-hint">ğŸ¤</span> é€‰æ‹©/æ”¾å¤§å›¾ç‰‡ |
                <span class="key gesture-hint">ğŸ‘‰</span> å³æ»‘æ—‹è½¬è§†è§’
            </div>
        </div>

        <!-- å›¾ç‰‡é€‰æ‹©æŒ‡ç¤ºå™¨ -->
        <div class="photo-indicator" id="photo-indicator"></div>

        <!-- å›¾ç‰‡æ”¾å¤§é¢æ¿ -->
        <div id="photo-detail-panel">
            <button id="photo-detail-close" onclick="closePhotoDetail()">Ã—</button>
            <img id="photo-detail-img" src="" alt="æ”¾å¤§å›¾ç‰‡">
            <div id="photo-detail-title">ç…§ç‰‡è¯¦æƒ…</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

        // --- è±ªåé…ç½® ---
        const CONFIG = {
            targetDate: '2026-01-01T00:00:00+08:00',
            // è±ªåç²’å­æ•°é‡
            goldCount: 1800,     // é‡‘çƒ
            silverCount: 1200,   // é“¶çƒ
            gemCount: 900,       // çº¢å®çŸ³
            emeraldCount: 700,   // ç¿¡ç¿ 
            diamondCount: 500,   // é’»çŸ³
            dustCount: 2500,     // å°˜åŸƒ
            snowCount: 3500,     // é›ªèŠ±
            sparkleCount: 2000,  // é—ªå…‰ç²’å­
            
            // è›‹ç³•å±‚çº§
            tiers: [ 
                { radius: 30, height: 18, yBottom: -30 }, 
                { radius: 22, height: 16, yBottom: -12 }, 
                { radius: 14, height: 14, yBottom: 4 } 
            ],
            
            cameraZ: 140,
            introParticleCount: 15000,
            
            // æ‰‹åŠ¿çµæ•åº¦
            gestureSensitivity: {
                fist: 0.35,      // æ¡æ‹³é˜ˆå€¼
                pinch: 0.08,     // æåˆé˜ˆå€¼
                swipe: 0.02      // æ»‘åŠ¨é˜ˆå€¼
            },
            
            // ç…§ç‰‡è®¾ç½®
            photoScale: {
                tree: 0.8,       // è›‹ç³•çŠ¶æ€å°ºå¯¸
                scatter: 1.2,    // æ•£å¼€çŠ¶æ€å°ºå¯¸
                zoom: 2.5        // æ”¾å¤§çŠ¶æ€å°ºå¯¸
            }
        };

        // çŠ¶æ€å¸¸é‡
        const STATE = { 
            TREE: 'tree', 
            SCATTER: 'scatter', 
            ZOOM: 'zoom',
            SELECT: 'select' 
        };
        
        const APP_MODE = { 
            INTRO: 'intro', 
            CAKE: 'cake',
            DETAIL: 'detail' 
        };

        // æ‰‹åŠ¿çŠ¶æ€
        const GESTURE = {
            NONE: 'none',
            FIST: 'fist',
            OPEN: 'open',
            PINCH: 'pinch',
            SWIPE_RIGHT: 'swipe_right',
            SWIPE_LEFT: 'swipe_left'
        };

        // å›¾ç‰‡è·¯å¾„
        const IMAGE_PATHS = [];
        for(let i=1; i<=13; i++) IMAGE_PATHS.push(`./images/${i}.jpg`);

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let mainGroup = new THREE.Group();
        let introGroup = new THREE.Group();
        let textGroup = new THREE.Group();
        let textMesh = null;
        let photoMeshes = [];
        let snowSystem, dustSystem, sparkleSystem;
        
        // è±ªåè£…é¥°
        let goldMesh, silverMesh, gemMesh, emeraldMesh, diamondMesh;
        let logicData = { 
            gold: [], 
            silver: [], 
            gem: [], 
            emerald: [], 
            diamond: [], 
            dust: [] 
        };
        
        let currentMode = APP_MODE.INTRO;
        let currentState = STATE.TREE;
        let targetState = STATE.TREE;
        let selectedPhotoIndex = -1;
        let zoomPhotoIndex = -1;
        let isPhotoDetailOpen = false;
        
        let introActive = true;
        let introParticles;
        let introLogic = [];
        let introTimelineStep = 0;
        let introTimer = 0;
        let cachedTextTargets = {};
        let isWarping = false;

        let isStarted = false;
        let isCountingDown = false;
        let time = 0;
        let frameCount = 0;

        // æ‰‹åŠ¿è¯†åˆ«
        let handPos = { x: 0, y: 0 };
        let lastHandPos = { x: 0, y: 0 };
        let isHandPresent = false;
        let rotationVelocity = { x: 0, y: 0 };
        let handLandmarker = null;
        let video = null;
        let lastVideoTime = -1;
        let isCameraActive = false;
        let currentGesture = GESTURE.NONE;
        let gestureHistory = [];
        const GESTURE_HISTORY_LENGTH = 5;
        
        // é€‰æ‹©ç³»ç»Ÿ
        let selectionRaycaster = new THREE.Raycaster();
        let selectionMouse = new THREE.Vector2();
        let selectedPhoto = null;
        let selectionTimeout = null;

        // éŸ³ä¹
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-control');
        let isFullscreenActive = false;

        // è¾…åŠ©å¯¹è±¡
        const dummy = new THREE.Object3D();

        // --- å·¥å…·å‡½æ•° ---
        function randomSpherePoint(r) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta), 
                r * Math.sin(phi) * Math.sin(theta), 
                r * Math.cos(phi)
            );
        }

        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; 
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;
            
            ctx.clearRect(0, 0, 128, 128);
            
            if (type === 'sparkle') { 
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 60);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.15, 'rgba(255, 240, 150, 1)'); 
                grad.addColorStop(0.5, 'rgba(255, 160, 0, 0.4)');  
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad; 
                ctx.fillRect(0, 0, 128, 128);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.moveTo(cx, 0); 
                ctx.lineTo(cx+4, cy); 
                ctx.lineTo(cx, 128); 
                ctx.lineTo(cx-4, cy);
                ctx.moveTo(0, cy); 
                ctx.lineTo(cx, cy-4); 
                ctx.lineTo(128, cy); 
                ctx.lineTo(cx, cy+4);
                ctx.fill();
                
            } else if (type === 'snow') { 
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
                grad.addColorStop(0, 'rgba(255, 250, 230, 0.9)');
                grad.addColorStop(0.4, 'rgba(255, 215, 0, 0.4)'); 
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad; 
                ctx.fillRect(0, 0, 128, 128);
                
            } else if (type === 'glow') {
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.3, 'rgba(255, 215, 0, 0.8)');
                grad.addColorStop(0.6, 'rgba(255, 140, 0, 0.4)');
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 128, 128);
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function updateLoadingProgress(percent, text) {
            const progressBar = document.getElementById('loading-progress-bar');
            const loadingText = document.getElementById('loading-text');
            
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }
            
            if (loadingText) {
                loadingText.innerText = text;
            }
        }

        // --- 1. æš´åŠ›å¯åŠ¨å…¥å£ ---
        window.forceNewYear = function() {
            console.log("ğŸš€ å¼ºåˆ¶å¯åŠ¨ï¼");
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('time-panel').style.opacity = 0;
            document.getElementById('top-right-controls').style.display = 'flex';
            
            bgm.volume = 0.8; 
            bgm.play().then(() => {
                musicBtn.classList.remove('paused');
                musicBtn.style.color = '#00ff00';
            }).catch(e => {
                console.log("éŸ³ä¹æ’­æ”¾å¤±è´¥:", e);
            });
            
            isStarted = true;
            isCountingDown = true;
            document.getElementById('ui-layer').style.display = 'block';

            // è·³è¿‡å€’è®¡æ—¶ï¼Œç›´æ¥è¿›å…¥è›‹ç³•åœºæ™¯
            skipIntroToCake();
        };

        function skipIntroToCake() {
            introActive = false;
            if (introGroup && scene) scene.remove(introGroup);
            currentMode = APP_MODE.CAKE;
            if (mainGroup) {
                mainGroup.visible = true;
                mainGroup.scale.set(1, 1, 1);
            }
            
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('top-right-controls').style.display = 'flex';
            document.getElementById('video-container').style.display = 'block';
            
            // æ˜¾ç¤ºè›‹ç³•ç…§ç‰‡
            setTimeout(() => {
                photoMeshes.forEach((m, idx) => {
                    if (m) {
                        m.visible = true;
                        m.scale.set(0, 0, 0);
                        new TWEEN.Tween(m.scale)
                            .to({x: 1, y: 1, z: 1}, 1000)
                            .delay(idx * 50)
                            .easing(TWEEN.Easing.Back.Out)
                            .start();
                    }
                });
                
                // åˆ›å»ºæ–°å¹´å¿«ä¹æ–‡å­—
                createNewYearText();
                
                // å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
                setupMediaPipe();
            }, 500);
        }

        // --- 2. æ­£å¸¸å¯åŠ¨å…¥å£ ---
        window.startExperience = function() {
            const ss = document.getElementById('start-screen');
            ss.style.opacity = 0;
            setTimeout(() => ss.style.display = 'none', 800);
            
            bgm.volume = 0.8;
            bgm.play().then(() => {
                musicBtn.classList.remove('paused');
                musicBtn.style.color = '#00ff00';
            }).catch(() => {
                console.log("éŸ³ä¹è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œè¯·ç‚¹å‡»éŸ³ä¹æŒ‰é’®");
            });
            
            isStarted = true;
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('top-right-controls').style.display = 'flex';
            
            // æ˜¾ç¤ºåŠ è½½è¿›åº¦æ¡
            document.getElementById('loading-progress').style.display = 'block';
            updateLoadingProgress(10, "åˆå§‹åŒ–åœºæ™¯...");
            
            // å¯åŠ¨æ—¶é’Ÿ
            setInterval(updateClock, 1000);
            updateClock();
            
            // é¢„åŠ è½½å€’è®¡æ—¶ç²’å­åŠ¨ç”»
            setTimeout(() => {
                updateLoadingProgress(30, "å‡†å¤‡å€’è®¡æ—¶åŠ¨ç”»...");
                startIntroCountdown();
            }, 500);
        };

        // --- éŸ³ä¹æ§åˆ¶ ---
        window.toggleMusic = function() {
            if(bgm.paused) { 
                bgm.play(); 
                musicBtn.classList.remove('paused'); 
                musicBtn.style.color = '#00ff00';
            } else { 
                bgm.pause(); 
                musicBtn.classList.add('paused'); 
                musicBtn.style.color = '#ffd700';
            }
        };

        // --- å…¨å±æ§åˆ¶ ---
        window.toggleFullscreen = function() {
            const elem = document.documentElement;
            isFullscreenActive = !isFullscreenActive;

            if (isFullscreenActive) {
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        };

        // --- æ‘„åƒå¤´å¤§å°åˆ‡æ¢ ---
        window.toggleVideoSize = function() {
            document.getElementById('video-container').classList.toggle('minimized');
        };

        // --- å›¾ç‰‡è¯¦æƒ…æ§åˆ¶ ---
        window.closePhotoDetail = function() {
            const panel = document.getElementById('photo-detail-panel');
            panel.classList.remove('active');
            isPhotoDetailOpen = false;
            
            // æ¢å¤è›‹ç³•åœºæ™¯
            currentMode = APP_MODE.CAKE;
            if (selectedPhoto) {
                selectedPhoto.material.emissiveIntensity = 0.3;
                selectedPhoto = null;
            }
            selectedPhotoIndex = -1;
        };

        function openPhotoDetail(index) {
            if (index < 0 || index >= photoMeshes.length || !photoMeshes[index]) return;
            
            const mesh = photoMeshes[index];
            const imgElement = document.getElementById('photo-detail-img');
            const titleElement = document.getElementById('photo-detail-title');
            const panel = document.getElementById('photo-detail-panel');
            
            // ä»çº¹ç†ä¸­è·å–å›¾ç‰‡URL
            if (mesh.material.map && mesh.material.map.image) {
                imgElement.src = mesh.material.map.image.src;
                titleElement.textContent = `å›å¿† ${index + 1}`;
                
                panel.classList.add('active');
                isPhotoDetailOpen = true;
                currentMode = APP_MODE.DETAIL;
                
                // é«˜äº®é€‰ä¸­çš„å›¾ç‰‡
                if (selectedPhoto) {
                    selectedPhoto.material.emissiveIntensity = 0.3;
                }
                selectedPhoto = mesh;
                selectedPhoto.material.emissiveIntensity = 1.0;
                selectedPhotoIndex = index;
            }
        }

        // --- æ—¶é’Ÿé€»è¾‘ ---
        function updateClock() {
            if(isCountingDown || currentMode === APP_MODE.DETAIL) return;
            
            const now = new Date();
            const target = new Date(CONFIG.targetDate);
            const diff = target - now;

            // åŒ—äº¬æ—¶é—´
            const beijing = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3600000 * 8));
            document.getElementById('clock-display').innerText = 
                `${String(beijing.getHours()).padStart(2,'0')}:${String(beijing.getMinutes()).padStart(2,'0')}:${String(beijing.getSeconds()).padStart(2,'0')}`;
            
            if(diff > 0) {
                const d = Math.floor(diff / 86400000);
                const h = Math.floor((diff % 86400000) / 3600000);
                document.getElementById('countdown-display').innerText = 
                    `è·ç¦» 2026 ç››å…¸å¼€å¯è¿˜æœ‰ ${d} å¤© ${h} å°æ—¶`;
                    
                if(diff < 11000 && !introActive) {
                    startFinalCountdown(10);
                }
            } else if (diff <= 0) {
                document.getElementById('countdown-display').innerText = "2026æ–°å¹´å¿«ä¹ï¼";
            }
        }

        // --- å€’è®¡æ—¶åŠ¨ç”» ---
        function startFinalCountdown(num) {
            isCountingDown = true;
            document.getElementById('time-panel').style.opacity = 0;
            new TWEEN.Tween(camera.position)
                .to({z: 90}, num * 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            playNum(num);
        }

        function playNum(n) {
            if(n < 1) { 
                showHappyNewYear(); 
                return; 
            }
            show3DText(String(n));
            setTimeout(() => playNum(n-1), 1000);
        }

        function showHappyNewYear() {
            show3DText("Happy New Year");
            setTimeout(() => {
                show3DText("2026");
                setTimeout(() => {
                    textGroup.clear();
                    new TWEEN.Tween(camera.position)
                        .to({z: CONFIG.cameraZ}, 2000)
                        .easing(TWEEN.Easing.Cubic.Out)
                        .start();
                    
                    // æ˜¾ç¤ºè›‹ç³•ç…§ç‰‡
                    photoMeshes.forEach((m, idx) => {
                        if (m) {
                            m.visible = true;
                            m.scale.set(0, 0, 0);
                            new TWEEN.Tween(m.scale)
                                .to({x: 1, y: 1, z: 1}, 1000)
                                .delay(idx * 50)
                                .easing(TWEEN.Easing.Back.Out)
                                .start();
                        }
                    });
                    
                    // åˆ›å»ºæ–°å¹´å¿«ä¹æ–‡å­—
                    createNewYearText();
                    
                }, 2000);
            }, 2000);
        }

        // --- æ–°å¹´å¿«ä¹æ–‡å­— ---
        function createNewYearText() {
            if (textMesh && mainGroup.children.includes(textMesh)) {
                mainGroup.remove(textMesh);
            }
            
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 2048; 
            textCanvas.height = 512;
            const ctx = textCanvas.getContext('2d');
            ctx.clearRect(0, 0, 2048, 512);
            ctx.font = '900 180px "Microsoft YaHei", sans-serif'; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';
            
            // æè¾¹
            ctx.strokeStyle = 'rgba(255, 180, 0, 0.9)'; 
            ctx.lineWidth = 6;
            ctx.shadowColor = '#ffaa00'; 
            ctx.shadowBlur = 40; 
            ctx.strokeText('Y ç¥ä½ æ–°å¹´å¿«ä¹', 1024, 256);

            // æ¸å˜å¡«å……
            const gradient = ctx.createLinearGradient(0, 100, 0, 400);
            gradient.addColorStop(0, '#ffffff'); 
            gradient.addColorStop(0.3, '#ffd700');
            gradient.addColorStop(0.7, '#ff8c00'); 
            gradient.addColorStop(1, '#8b4500');
            ctx.fillStyle = gradient; 
            ctx.shadowBlur = 0; 
            ctx.fillText('Y ç¥ä½ æ–°å¹´å¿«ä¹', 1024, 256);
            
            const textTex = new THREE.CanvasTexture(textCanvas);
            textTex.colorSpace = THREE.SRGBColorSpace;
            const textMat = new THREE.MeshBasicMaterial({ 
                map: textTex, 
                transparent: true, 
                opacity: 0, 
                blending: THREE.AdditiveBlending, 
                side: THREE.DoubleSide, 
                depthWrite: false
            });
            
            textMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 20), textMat);
            const topTier = CONFIG.tiers[CONFIG.tiers.length - 1];
            const textY = topTier.yBottom + topTier.height + 15;
            textMesh.position.set(0, textY, 0);
            mainGroup.add(textMesh);
            
            // æµ®åŠ¨åŠ¨ç”»
            new TWEEN.Tween(textMesh.position)
                .to({y: textY + 4}, 2500)
                .yoyo(true)
                .repeat(Infinity)
                .easing(TWEEN.Easing.Sinusoidal.InOut)
                .start();
                
            // æ¸æ˜¾åŠ¨ç”»
            new TWEEN.Tween(textMat)
                .to({opacity: 1}, 1500)
                .start();
        }

        function show3DText(str) {
            if (!fontGlobal) return;
            
            textGroup.clear();
            const size = str.length > 3 ? 15 : 40;
            const geo = new TextGeometry(str, { 
                font: fontGlobal, 
                size: size, 
                height: 2 
            });
            geo.center();
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 1
            });
            const mesh = new THREE.Mesh(geo, mat);
            textGroup.add(mesh);
            
            mesh.scale.set(0, 0, 0);
            new TWEEN.Tween(mesh.scale)
                .to({x: 1, y: 1, z: 1}, 500)
                .easing(TWEEN.Easing.Back.Out)
                .start();
            new TWEEN.Tween(mesh.material)
                .to({opacity: 0}, 500)
                .delay(500)
                .start()
                .onComplete(() => {
                    textGroup.remove(mesh);
                    geo.dispose();
                    mat.dispose();
                });
        }

        // --- 3D åˆå§‹åŒ– ---
        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x2b1d0e, 0.002);

                camera = new THREE.PerspectiveCamera(
                    50, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.z = CONFIG.cameraZ;

                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true, 
                    powerPreference: "high-performance" 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                container.appendChild(renderer.domElement);

                // ç¯å¢ƒå…‰
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

                // åæœŸå¤„ç†
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight), 
                    1.5, 
                    0.4, 
                    0.85
                );
                bloomPass.threshold = 0.85;
                bloomPass.strength = 0.8;
                bloomPass.radius = 0.5;
                
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // å…‰ç…§
                scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                
                const mainLight = new THREE.DirectionalLight(0xffd700, 1.5);
                mainLight.position.set(50, 100, 50);
                scene.add(mainLight);
                
                const fillLight = new THREE.PointLight(0xffaa00, 1, 300);
                fillLight.position.set(-50, 50, -50);
                scene.add(fillLight);
                
                const backLight = new THREE.PointLight(0x00aaff, 0.8, 200);
                backLight.position.set(0, 30, -100);
                scene.add(backLight);

                // åˆ›å»ºè±ªåè£…é¥°
                updateLoadingProgress(50, "åˆ›å»ºè±ªåè£…é¥°...");
                createLuxuryDecorations();
                createDust();
                createGoldenSnow();
                createSparkleSystem();
                createStarField();
                
                scene.add(mainGroup); 
                scene.add(textGroup);
                
                mainGroup.visible = false;

                // åˆ›å»ºç²’å­ç³»ç»Ÿ
                updateLoadingProgress(60, "åˆ›å»ºç²’å­ç³»ç»Ÿ...");
                createIntroSystem();

                // åŠ è½½å­—ä½“
                const loader = new FontLoader();
                loader.load(
                    'https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', 
                    f => {
                        fontGlobal = f;
                        updateLoadingProgress(70, "åŠ è½½ç…§ç‰‡èµ„æº...");
                        loadPhotos();
                        
                        // é¢„è®¡ç®—å€’è®¡æ—¶ç›®æ ‡
                        setTimeout(() => {
                            updateLoadingProgress(90, "ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½...");
                            optimizePerformance();
                            updateLoadingProgress(100, "å‡†å¤‡å°±ç»ªï¼");
                        }, 1000);
                    },
                    undefined,
                    (err) => {
                        console.error("å­—ä½“åŠ è½½å¤±è´¥:", err);
                        updateLoadingProgress(100, "å­—ä½“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ");
                        fontGlobal = null;
                        loadPhotos();
                    }
                );

                // çª—å£å¤§å°è°ƒæ•´äº‹ä»¶
                window.addEventListener('resize', onWindowResize);
                
                // å¼€å§‹åŠ¨ç”»
                animate();
                
            } catch (e) {
                console.error("Three.js åˆå§‹åŒ–å¤±è´¥:", e);
                updateLoadingProgress(100, "åˆå§‹åŒ–é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢");
            }
        }

        function optimizePerformance() {
            // ä¼˜åŒ–æ¸²æŸ“è®¾ç½®
            if (renderer) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            }
            
            // åˆå¹¶å‡ ä½•ä½“ï¼ˆå¯é€‰ï¼‰
            console.log("æ€§èƒ½ä¼˜åŒ–å®Œæˆ");
        }

        // --- è±ªåè£…é¥° ---
        function createLuxuryDecorations() {
            // ä¼˜åŒ–æè´¨
            const goldMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xffcc00, 
                metalness: 1.0, 
                roughness: 0.05, 
                clearcoat: 1.0, 
                emissive: 0xffaa00, 
                emissiveIntensity: 1.0,
                envMapIntensity: 2.0
            });
            
            const silverMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                metalness: 0.95, 
                roughness: 0.1, 
                emissive: 0x666666, 
                emissiveIntensity: 0.3
            });
            
            const gemMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xff0044, 
                metalness: 0.2, 
                roughness: 0.0, 
                transmission: 0.9, 
                thickness: 2.0, 
                emissive: 0xaa0022, 
                emissiveIntensity: 0.8,
                ior: 2.4
            });
            
            const emeraldMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x00ccff, 
                metalness: 0.3, 
                roughness: 0.05, 
                transmission: 0.7, 
                thickness: 1.8, 
                emissive: 0x004488, 
                emissiveIntensity: 0.7
            });
            
            const diamondMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                metalness: 0.1, 
                roughness: 0.01, 
                transmission: 0.95, 
                thickness: 1.5, 
                emissive: 0xffffff, 
                emissiveIntensity: 0.2,
                ior: 2.42
            });

            goldMesh = createInstancedMesh(
                new THREE.SphereGeometry(0.7, 24, 24), 
                goldMat, 
                CONFIG.goldCount, 
                logicData.gold
            );
            
            silverMesh = createInstancedMesh(
                new THREE.IcosahedronGeometry(0.6, 2), 
                silverMat, 
                CONFIG.silverCount, 
                logicData.silver
            );
            
            gemMesh = createInstancedMesh(
                new THREE.OctahedronGeometry(0.8, 1), 
                gemMat, 
                CONFIG.gemCount, 
                logicData.gem
            );
            
            emeraldMesh = createInstancedMesh(
                new THREE.TetrahedronGeometry(0.9, 0), 
                emeraldMat, 
                CONFIG.emeraldCount, 
                logicData.emerald
            );
            
            diamondMesh = createInstancedMesh(
                new THREE.DodecahedronGeometry(0.65, 0), 
                diamondMat, 
                CONFIG.diamondCount, 
                logicData.diamond
            );

            // é¡¶éƒ¨çš‡å† 
            createCrown();
        }

        function createCrown() {
            const crownGroup = new THREE.Group();
            const crownMat = new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                metalness: 1.0,
                roughness: 0.05,
                emissive: 0xffaa00,
                emissiveIntensity: 1.0
            });
            
            // çš‡å† åº•åº§
            const baseGeometry = new THREE.CylinderGeometry(8, 10, 2, 16);
            const base = new THREE.Mesh(baseGeometry, crownMat);
            base.position.y = CONFIG.tiers[2].yBottom + CONFIG.tiers[2].height + 1;
            crownGroup.add(base);
            
            // çš‡å† å°–åˆº
            const spikeGeometry = new THREE.ConeGeometry(0.8, 4, 8);
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const spike = new THREE.Mesh(spikeGeometry, crownMat);
                spike.position.set(
                    Math.cos(angle) * 9,
                    CONFIG.tiers[2].yBottom + CONFIG.tiers[2].height + 3,
                    Math.sin(angle) * 9
                );
                spike.rotation.x = Math.PI / 6;
                crownGroup.add(spike);
            }
            
            // ä¸­å¿ƒå¤§å®çŸ³
            const bigGemMat = new THREE.MeshPhysicalMaterial({
                color: 0xff0044,
                metalness: 0.1,
                roughness: 0.0,
                transmission: 0.95,
                thickness: 3,
                emissive: 0xff0044,
                emissiveIntensity: 1.0
            });
            
            const bigGem = new THREE.Mesh(new THREE.OctahedronGeometry(2, 2), bigGemMat);
            bigGem.position.y = CONFIG.tiers[2].yBottom + CONFIG.tiers[2].height + 4;
            crownGroup.add(bigGem);
            
            crownGroup.userData = {
                treePos: new THREE.Vector3(0, 0, 0),
                scatterPos: new THREE.Vector3(0, 80, 0)
            };
            
            mainGroup.add(crownGroup);
            logicData.crown = crownGroup;
        }

        function createInstancedMesh(geo, mat, count, dataArray) {
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            mainGroup.add(mesh);
            
            for (let i = 0; i < count; i++) {
                const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
                const tier = CONFIG.tiers[tierIndex];
                const h = Math.random() * tier.height;
                const r = Math.sqrt(Math.random()) * tier.radius;
                let finalR = r;
                if (Math.random() > 0.3) finalR = tier.radius * (0.9 + Math.random() * 0.15);
                const theta = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(
                    finalR * Math.cos(theta), 
                    tier.yBottom + h, 
                    finalR * Math.sin(theta)
                );
                
                dataArray.push({
                    treePos: treePos,
                    scatterPos: randomSpherePoint(50 + Math.random() * 30),
                    currentPos: treePos.clone(),
                    scale: 0.5 + Math.random() * 0.8,
                    rotSpeed: new THREE.Euler(
                        Math.random() * 0.02 - 0.01,
                        Math.random() * 0.03 - 0.015,
                        Math.random() * 0.02 - 0.01
                    ),
                    rotation: new THREE.Euler(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    ),
                    tierIndex: tierIndex,
                    floatOffset: Math.random() * Math.PI * 2
                });
            }
            return mesh;
        }

        function createDust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const colors = [];
            const color = new THREE.Color(0xffccaa);
            
            for(let i = 0; i < CONFIG.dustCount; i++) {
                const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
                const tier = CONFIG.tiers[tierIndex];
                const r = tier.radius * (1.0 + Math.random() * 0.2);
                const theta = Math.random() * Math.PI * 2;
                const x = r * Math.cos(theta), 
                      y = tier.yBottom + Math.random() * tier.height, 
                      z = r * Math.sin(theta);
                pos.push(x, y, z);
                
                colors.push(color.r, color.g, color.b);
                
                logicData.dust.push({ 
                    treePos: new THREE.Vector3(x, y, z), 
                    scatterPos: randomSpherePoint(60), 
                    currentPos: new THREE.Vector3(x, y, z), 
                    tierIndex: tierIndex,
                    floatOffset: Math.random() * Math.PI * 2
                });
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            dustSystem = new THREE.Points(
                geo, 
                new THREE.PointsMaterial({ 
                    color: 0xffccaa, 
                    size: 0.8, 
                    transparent: true, 
                    opacity: 0.6, 
                    blending: THREE.AdditiveBlending, 
                    depthWrite: false,
                    vertexColors: true
                })
            );
            mainGroup.add(dustSystem);
        }

        function createGoldenSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = []; 
            const speeds = []; 
            const sizes = [];
            const floats = [];
            
            for(let i = 0; i < CONFIG.snowCount; i++) {
                pos.push(
                    (Math.random() - 0.5) * 400, 
                    (Math.random() - 0.5) * 400, 
                    (Math.random() - 0.5) * 300
                );
                speeds.push(0.02 + Math.random() * 0.1);
                sizes.push(1.5 + Math.random() * 3.5);
                floats.push(Math.random() * Math.PI * 2);
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('float', new THREE.Float32BufferAttribute(floats, 1));
            
            const mat = new THREE.PointsMaterial({
                color: 0xffeebb, 
                size: 1.0, 
                map: createTexture('snow'),
                transparent: true, 
                opacity: 0.7, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });
            
            snowSystem = new THREE.Points(geo, mat);
            snowSystem.userData = { 
                speeds: speeds,
                positions: pos 
            };
            scene.add(snowSystem);
        }

        function createSparkleSystem() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const sizes = [];
            const animations = [];
            
            for(let i = 0; i < CONFIG.sparkleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 100;
                const height = -20 + Math.random() * 60;
                
                pos.push(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );
                
                sizes.push(0.5 + Math.random() * 2);
                animations.push(Math.random() * Math.PI * 2);
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('animation', new THREE.Float32BufferAttribute(animations, 1));
            
            const mat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                map: createTexture('sparkle'),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            sparkleSystem = new THREE.Points(geo, mat);
            mainGroup.add(sparkleSystem);
        }

        function createStarField() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const colors = [];
            const color = new THREE.Color(0xffddaa);
            
            for(let i = 0; i < 1000; i++) {
                pos.push(
                    (Math.random() - 0.5) * 1200, 
                    (Math.random() - 0.5) * 1200, 
                    (Math.random() - 0.5) * 1200
                );
                colors.push(color.r, color.g, color.b);
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            scene.add(new THREE.Points(
                geo, 
                new THREE.PointsMaterial({
                    color: 0xffddaa, 
                    size: 1.8, 
                    transparent: true, 
                    opacity: 0.5,
                    vertexColors: true
                })
            ));
        }

        // --- ç²’å­ç³»ç»Ÿ ---
        function createIntroSystem() {
            const geo = new THREE.BufferGeometry();
            const positions = []; 
            const colors = []; 
            const sizes = [];
            const flash = []; 
            const velocities = [];
            const color1 = new THREE.Color(0xffd700); 
            const color2 = new THREE.Color(0xffffff);

            for(let i = 0; i < CONFIG.introParticleCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 300, 
                    (Math.random() - 0.5) * 300, 
                    (Math.random() - 0.5) * 100
                );
                velocities.push(0, 0, 0);
                const c = Math.random() > 0.3 ? color1 : color2;
                colors.push(c.r * 3.0, c.g * 2.5, c.b * 1.5);
                sizes.push(1.0 + Math.random() * 2.5);
                flash.push(Math.random() * Math.PI);

                introLogic.push({ 
                    currentPos: new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]), 
                    targetPos: new THREE.Vector3(0, 0, 0),
                    speed: 0.05 + Math.random() * 0.1
                });
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('flash', new THREE.Float32BufferAttribute(flash, 1));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const mat = new THREE.PointsMaterial({
                size: 1.5, 
                vertexColors: true, 
                map: createTexture('sparkle'),
                blending: THREE.AdditiveBlending, 
                depthWrite: false, 
                transparent: true, 
                opacity: 1.0,
                toneMapped: false
            });
            
            introParticles = new THREE.Points(geo, mat);
            introGroup.add(introParticles);
            scene.add(introGroup);
        }

        function startIntroCountdown() {
            introTimelineStep = 1;
            applyTargets("5");
            introTimer = Date.now();
        }

        function applyTargets(key) {
            // ç”Ÿæˆç®€å•çš„ç›®æ ‡ä½ç½®
            const targets = [];
            const size = key === "2026" ? 50 : 80;
            
            for(let i = 0; i < CONFIG.introParticleCount; i++) {
                if (key === "2026") {
                    // 2026æ–‡å­—å½¢çŠ¶
                    const angle = (i / CONFIG.introParticleCount) * Math.PI * 2;
                    const radius = size * (0.8 + Math.random() * 0.4);
                    targets.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * size,
                        Math.sin(angle) * radius
                    ));
                } else {
                    // æ•°å­—å½¢çŠ¶
                    const angle = (i / CONFIG.introParticleCount) * Math.PI * 2;
                    const radius = size;
                    targets.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        (Math.random() - 0.5) * 50
                    ));
                }
            }
            
            for(let i = 0; i < CONFIG.introParticleCount; i++) {
                if (i < targets.length) {
                    introLogic[i].targetPos.copy(targets[i]);
                } else {
                    introLogic[i].targetPos.set(0, 0, 0);
                }
            }
        }

        // --- å›¾ç‰‡åŠ è½½ ---
        function loadPhotos() {
            const loader = new THREE.TextureLoader();
            let loadedCount = 0;
            const totalCount = IMAGE_PATHS.length;
            
            IMAGE_PATHS.forEach((path, idx) => {
                loader.load(
                    path, 
                    tex => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        const aspect = tex.image.width / tex.image.height;
                        let w = 6, h = 6;
                        if(aspect > 1) {
                            h = w / aspect;
                        } else {
                            w = h * aspect;
                        }
                        
                        // é«˜è´¨é‡æè´¨
                        const mat = new THREE.MeshPhysicalMaterial({ 
                            map: tex, 
                            side: THREE.DoubleSide, 
                            roughness: 0.1,
                            metalness: 0.1,
                            clearcoat: 0.5,
                            emissive: 0x222222, 
                            emissiveIntensity: 0.3,
                            envMapIntensity: 1.0
                        });
                        
                        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
                        
                        // è±ªåç›¸æ¡†
                        const frameMat = new THREE.MeshPhysicalMaterial({
                            color: 0xffd700, 
                            roughness: 0.1, 
                            metalness: 1.0, 
                            emissive: 0xaa6600, 
                            emissiveIntensity: 0.5,
                            clearcoat: 1.0
                        });
                        
                        const frame = new THREE.Mesh(
                            new THREE.BoxGeometry(w + 0.3, h + 0.3, 0.15), 
                            frameMat
                        );
                        frame.position.z = -0.08;
                        mesh.add(frame);
                        
                        // éšæœºåˆ†é…å±‚çº§
                        const tierIndex = idx % CONFIG.tiers.length;
                        const tier = CONFIG.tiers[tierIndex];
                        const h_pos = tier.yBottom + Math.random() * tier.height;
                        const r = tier.radius * 1.2;
                        const angle = (idx / totalCount) * Math.PI * 2;
                        
                        const treePos = new THREE.Vector3(
                            r * Math.cos(angle),
                            h_pos,
                            r * Math.sin(angle)
                        );
                        
                        // æ•£å¼€ä½ç½®
                        const scatterAngle = Math.random() * Math.PI * 2;
                        const scatterDist = 40 + Math.random() * 40;
                        const scatterHeight = -20 + Math.random() * 60;
                        
                        const scatterPos = new THREE.Vector3(
                            Math.cos(scatterAngle) * scatterDist,
                            scatterHeight,
                            Math.sin(scatterAngle) * scatterDist
                        );
                        
                        mesh.userData = { 
                            treePos: treePos, 
                            scatterPos: scatterPos,
                            baseRot: new THREE.Euler(0, angle + Math.PI/2, 0),
                            index: idx,
                            selected: false,
                            originalEmissiveIntensity: 0.3
                        };
                        
                        mesh.position.copy(treePos);
                        mesh.rotation.copy(mesh.userData.baseRot);
                        mesh.visible = false;
                        
                        // æ·»åŠ é€‰æ‹©é«˜äº®æ•ˆæœ
                        const highlightGeometry = new THREE.PlaneGeometry(w * 1.1, h * 1.1);
                        const highlightMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ff00,
                            transparent: true,
                            opacity: 0,
                            side: THREE.DoubleSide
                        });
                        
                        const highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
                        highlightMesh.position.z = 0.01;
                        mesh.add(highlightMesh);
                        mesh.userData.highlightMesh = highlightMesh;
                        
                        photoMeshes.push(mesh);
                        mainGroup.add(mesh);
                        
                        loadedCount++;
                        const progress = Math.floor((loadedCount / totalCount) * 100);
                        updateLoadingProgress(70 + progress * 0.2, `åŠ è½½ç…§ç‰‡ ${loadedCount}/${totalCount}`);
                        
                        if (loadedCount === totalCount) {
                            console.log(`æ‰€æœ‰ ${totalCount} å¼ ç…§ç‰‡åŠ è½½å®Œæˆ`);
                        }
                    }, 
                    undefined, 
                    (err) => {
                        console.error(`åŠ è½½å›¾ç‰‡ ${path} å¤±è´¥:`, err);
                        loadedCount++;
                    }
                );
            });
        }

        // --- æ‰‹åŠ¿è¯†åˆ«ä¼˜åŒ– ---
        async function setupMediaPipe() {
            if (handLandmarker) {
                handLandmarker.close();
                handLandmarker = null;
            }
            
            const statusText = document.getElementById('status-text');
            statusText.innerText = "æ­£åœ¨è¿æ¥è§†è§‰å¼•æ“...";
            statusText.style.color = "#ffd700";
            
            try {
                // åœæ­¢ç°æœ‰è§†é¢‘æµ
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: "user", 
                        width: { ideal: 640 }, 
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    } 
                });
                
                video = document.getElementById("input-video");
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(() => {
                            isCameraActive = true;
                            initLandmarker();
                            resolve();
                        }).catch(err => {
                            console.error("è§†é¢‘æ’­æ”¾å¤±è´¥:", err);
                            statusText.innerText = "è§†é¢‘æ’­æ”¾å¤±è´¥";
                            isCameraActive = false;
                            resolve();
                        });
                    };
                });
                
            } catch (err) {
                console.warn("æ‘„åƒå¤´è®¿é—®å¤±è´¥:", err);
                document.getElementById('video-container').classList.add('error');
                statusText.innerText = "âš ï¸ æ‘„åƒå¤´ä¸å¯ç”¨ (å·²åˆ‡æ¢è‡³è§¦æ§æ¨¡å¼)";
                statusText.style.color = "#ff4444";
                isCameraActive = false;
                
                // å¼€å¯é¼ æ ‡æ§åˆ¶
                setupMouseControl();
            }
        }

        function setupMouseControl() {
            const container = document.getElementById('canvas-container');
            let isMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            container.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç…§ç‰‡
                const mouse = new THREE.Vector2(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );
                
                checkPhotoSelection(mouse);
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isMouseDown || currentMode !== APP_MODE.CAKE) return;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                if (currentState === STATE.SCATTER) {
                    rotationVelocity.y = deltaX * 0.005;
                    rotationVelocity.x = deltaY * 0.005;
                }
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            container.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            container.addEventListener('mouseleave', () => {
                isMouseDown = false;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isMouseDown = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    
                    const mouse = new THREE.Vector2(
                        (e.touches[0].clientX / window.innerWidth) * 2 - 1,
                        -(e.touches[0].clientY / window.innerHeight) * 2 + 1
                    );
                    
                    checkPhotoSelection(mouse);
                }
            });
            
            container.addEventListener('touchmove', (e) => {
                if (!isMouseDown || e.touches.length !== 1 || currentMode !== APP_MODE.CAKE) return;
                e.preventDefault();
                
                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;
                
                if (currentState === STATE.SCATTER) {
                    rotationVelocity.y = deltaX * 0.005;
                    rotationVelocity.x = deltaY * 0.005;
                }
                
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            });
            
            container.addEventListener('touchend', () => {
                isMouseDown = false;
            });
            
            // åŒå‡»æ”¾å¤§ç…§ç‰‡
            let lastClickTime = 0;
            container.addEventListener('click', (e) => {
                const currentTime = new Date().getTime();
                const timeDiff = currentTime - lastClickTime;
                
                if (timeDiff < 300 && selectedPhotoIndex >= 0) {
                    // åŒå‡»æ”¾å¤§é€‰ä¸­çš„ç…§ç‰‡
                    openPhotoDetail(selectedPhotoIndex);
                }
                
                lastClickTime = currentTime;
            });
            
            document.getElementById('status-text').innerText = "é¼ æ ‡/è§¦æ§æ¨¡å¼å·²å¯ç”¨";
        }

        function checkPhotoSelection(mouse) {
            if (currentState !== STATE.SCATTER || photoMeshes.length === 0) return;
            
            selectionRaycaster.setFromCamera(mouse, camera);
            const intersects = selectionRaycaster.intersectObjects(photoMeshes);
            
            if (intersects.length > 0) {
                const selectedMesh = intersects[0].object;
                const index = photoMeshes.indexOf(selectedMesh);
                
                if (index >= 0) {
                    selectPhoto(index);
                }
            }
        }

        function selectPhoto(index) {
            // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
            if (selectedPhotoIndex >= 0 && selectedPhotoIndex < photoMeshes.length) {
                const prevMesh = photoMeshes[selectedPhotoIndex];
                if (prevMesh && prevMesh.userData.highlightMesh) {
                    prevMesh.userData.highlightMesh.material.opacity = 0;
                    prevMesh.material.emissiveIntensity = prevMesh.userData.originalEmissiveIntensity;
                }
            }
            
            // è®¾ç½®æ–°çš„é€‰æ‹©
            selectedPhotoIndex = index;
            const mesh = photoMeshes[index];
            
            if (mesh && mesh.userData.highlightMesh) {
                mesh.userData.highlightMesh.material.opacity = 0.3;
                mesh.material.emissiveIntensity = 1.0;
                selectedPhoto = mesh;
                
                // æ›´æ–°çŠ¶æ€æç¤º
                document.getElementById('status-text').innerHTML = 
                    `å·²é€‰æ‹©ç…§ç‰‡ <span style="color:#00ff00">${index + 1}</span> (åŒå‡»æ”¾å¤§)`;
                
                // æ˜¾ç¤ºé€‰æ‹©æŒ‡ç¤ºå™¨
                const indicator = document.getElementById('photo-indicator');
                const worldPosition = new THREE.Vector3();
                mesh.getWorldPosition(worldPosition);
                const screenPosition = worldPosition.clone().project(camera);
                
                indicator.style.left = ((screenPosition.x * 0.5 + 0.5) * window.innerWidth - 5) + 'px';
                indicator.style.top = (( - screenPosition.y * 0.5 + 0.5) * window.innerHeight - 5) + 'px';
                indicator.style.display = 'block';
                
                // 3ç§’åéšè—æŒ‡ç¤ºå™¨
                clearTimeout(selectionTimeout);
                selectionTimeout = setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }
        }

        async function initLandmarker() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, 
                        delegate: "GPU" 
                    },
                    runningMode: "VIDEO", 
                    numHands: 1,
                    minHandDetectionConfidence: 0.5,
                    minHandPresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                document.getElementById('status-text').innerText = "è§†è§‰å¼•æ“å·²è¿æ¥";
                document.getElementById('status-text').style.color = "#00ff00";
                
                predictWebcam();
                
            } catch (err) {
                console.error("æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥:", err);
                document.getElementById('status-text').innerText = "æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥";
                document.getElementById('status-text').style.color = "#ff4444";
                isCameraActive = false;
                setupMouseControl();
            }
        }

        async function predictWebcam() {
            if (!isCameraActive || !handLandmarker || !video || video.readyState < 2) {
                requestAnimationFrame(predictWebcam);
                return;
            }
            
            const now = performance.now();
            
            // é™åˆ¶æ£€æµ‹é¢‘ç‡
            if (now - lastVideoTime < 33) { // ~30fps
                requestAnimationFrame(predictWebcam);
                return;
            }
            
            lastVideoTime = now;
            
            try {
                const canvas = document.getElementById('skeleton-canvas');
                const ctx = canvas.getContext('2d');
                
                // è°ƒæ•´ç”»å¸ƒå¤§å°ä»¥åŒ¹é…è§†é¢‘
                if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }
                
                const result = handLandmarker.detectForVideo(video, now);
                
                // æ¸…é™¤ç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (result.landmarks && result.landmarks.length > 0) {
                    const landmarks = result.landmarks[0];
                    drawSkeleton(ctx, landmarks, canvas.width, canvas.height);
                    handleGesture(landmarks);
                    isHandPresent = true;
                } else {
                    isHandPresent = false;
                    currentGesture = GESTURE.NONE;
                }
                
            } catch (e) {
                console.error("æ‰‹åŠ¿è¯†åˆ«é”™è¯¯:", e);
            }
            
            requestAnimationFrame(predictWebcam);
        }

        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#00ff00';
            ctx.fillStyle = '#ff3300';
            
            // æ‰‹æŒ
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const point = landmarks[i * 4];
                if (i === 0) {
                    ctx.moveTo(point.x * w, point.y * h);
                } else {
                    ctx.lineTo(point.x * w, point.y * h);
                }
            }
            ctx.closePath();
            ctx.stroke();
            
            // æ‰‹æŒ‡è¿æ¥çº¿
            const connections = [
                [0,1,2,3,4],        // æ‹‡æŒ‡
                [0,5,6,7,8],        // é£ŸæŒ‡
                [0,9,10,11,12],     // ä¸­æŒ‡
                [0,13,14,15,16],    // æ— åæŒ‡
                [0,17,18,19,20]     // å°æŒ‡
            ];
            
            connections.forEach(finger => {
                ctx.beginPath();
                for (let i = 0; i < finger.length; i++) {
                    const point = landmarks[finger[i]];
                    if (i === 0) {
                        ctx.moveTo(point.x * w, point.y * h);
                    } else {
                        ctx.lineTo(point.x * w, point.y * h);
                    }
                }
                ctx.stroke();
            });
            
            // å…³èŠ‚ç‚¹
            for(let i = 0; i < landmarks.length; i++) {
                const point = landmarks[i];
                ctx.beginPath();
                ctx.arc(point.x * w, point.y * h, 4, 0, 2 * Math.PI);
                
                // æŒ‡å°–ç”¨ä¸åŒé¢œè‰²
                if ([4,8,12,16,20].includes(i)) {
                    ctx.fillStyle = '#ff0000';
                } else if (i === 0) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#00aaff';
                }
                
                ctx.fill();
            }
        }

        function handleGesture(landmarks) {
            if (currentMode !== APP_MODE.CAKE || isPhotoDetailOpen) return;
            
            // è®¡ç®—æ‰‹æŒä¸­å¿ƒ
            const palmX = (landmarks[0].x + landmarks[5].x + landmarks[9].x + landmarks[13].x + landmarks[17].x) / 5;
            const palmY = (landmarks[0].y + landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 5;
            
            handPos.x = palmX;
            handPos.y = palmY;
            
            // è®¡ç®—æŒ‡å°–åˆ°æŒå¿ƒçš„è·ç¦»
            const fingertipIndices = [4, 8, 12, 16, 20];
            let foldedCount = 0;
            let totalDistance = 0;
            
            fingertipIndices.forEach(tipIndex => {
                const distance = Math.sqrt(
                    Math.pow(landmarks[tipIndex].x - landmarks[0].x, 2) +
                    Math.pow(landmarks[tipIndex].y - landmarks[0].y, 2)
                );
                totalDistance += distance;
                
                if (distance < CONFIG.gestureSensitivity.fist) {
                    foldedCount++;
                }
            });
            
            // è®¡ç®—é£ŸæŒ‡å’Œæ‹‡æŒ‡çš„è·ç¦»ï¼ˆæåˆï¼‰
            const pinchDistance = Math.sqrt(
                Math.pow(landmarks[4].x - landmarks[8].x, 2) +
                Math.pow(landmarks[4].y - landmarks[8].y, 2)
            );
            
            // æ‰‹åŠ¿è¯†åˆ«
            let newGesture = GESTURE.NONE;
            
            if (foldedCount >= 4) {
                newGesture = GESTURE.FIST;
            } else if (pinchDistance < CONFIG.gestureSensitivity.pinch) {
                newGesture = GESTURE.PINCH;
            } else if (foldedCount <= 1) {
                newGesture = GESTURE.OPEN;
            }
            
            // æ£€æµ‹æ»‘åŠ¨æ‰‹åŠ¿
            const deltaX = handPos.x - lastHandPos.x;
            const deltaY = handPos.y - lastHandPos.y;
            
            if (Math.abs(deltaX) > CONFIG.gestureSensitivity.swipe) {
                if (deltaX > 0) {
                    newGesture = GESTURE.SWIPE_RIGHT;
                } else {
                    newGesture = GESTURE.SWIPE_LEFT;
                }
            }
            
            // æ›´æ–°æ‰‹åŠ¿å†å²
            gestureHistory.push(newGesture);
            if (gestureHistory.length > GESTURE_HISTORY_LENGTH) {
                gestureHistory.shift();
            }
            
            // ä½¿ç”¨å†å²è®°å½•ç¡®å®šç¨³å®šæ‰‹åŠ¿
            const stableGesture = getStableGesture();
            
            if (stableGesture !== currentGesture) {
                currentGesture = stableGesture;
                processGesture(stableGesture);
            }
            
            lastHandPos.x = handPos.x;
            lastHandPos.y = handPos.y;
        }

        function getStableGesture() {
            if (gestureHistory.length < 3) return GESTURE.NONE;
            
            const counts = {};
            gestureHistory.forEach(gesture => {
                counts[gesture] = (counts[gesture] || 0) + 1;
            });
            
            let maxCount = 0;
            let stableGesture = GESTURE.NONE;
            
            Object.keys(counts).forEach(gesture => {
                if (counts[gesture] > maxCount) {
                    maxCount = counts[gesture];
                    stableGesture = gesture;
                }
            });
            
            return stableGesture;
        }

        function processGesture(gesture) {
            const status = document.getElementById('status-text');
            
            switch(gesture) {
                case GESTURE.FIST:
                    // èšåˆè›‹ç³•
                    if (currentState !== STATE.TREE) {
                        currentState = STATE.TREE;
                        zoomPhotoIndex = -1;
                        rotationVelocity.x = 0;
                        rotationVelocity.y = 0;
                        
                        status.innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>èšåˆæˆè›‹ç³•</span>";
                    }
                    break;
                    
                case GESTURE.OPEN:
                    // æ•£å¼€ç…§ç‰‡
                    if (currentState === STATE.TREE) {
                        currentState = STATE.SCATTER;
                        status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>æ˜Ÿäº‘æ•£å¼€</span>";
                    } else if (currentState === STATE.ZOOM) {
                        currentState = STATE.SCATTER;
                        zoomPhotoIndex = -1;
                        status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>æ˜Ÿäº‘æ•£å¼€</span>";
                    }
                    break;
                    
                case GESTURE.PINCH:
                    // é€‰æ‹©/æ”¾å¤§ç…§ç‰‡
                    if (currentState === STATE.SCATTER) {
                        if (selectedPhotoIndex >= 0) {
                            // æ”¾å¤§é€‰ä¸­çš„ç…§ç‰‡
                            currentState = STATE.ZOOM;
                            zoomPhotoIndex = selectedPhotoIndex;
                            status.innerHTML = `çŠ¶æ€: <span style='color:#ff00ff'>æ”¾å¤§ç…§ç‰‡ ${selectedPhotoIndex + 1}</span>`;
                        } else {
                            // å°è¯•é€‰æ‹©æœ€è¿‘çš„ç…§ç‰‡
                            selectNearestPhoto();
                            status.innerHTML = "çŠ¶æ€: <span style='color:#ffd700'>é€‰æ‹©ç…§ç‰‡ä¸­...</span>";
                        }
                    } else if (currentState === STATE.ZOOM) {
                        // åŒå‡»æ‰‹åŠ¿ - æ‰“å¼€è¯¦æƒ…
                        openPhotoDetail(zoomPhotoIndex);
                    }
                    break;
                    
                case GESTURE.SWIPE_RIGHT:
                    // å³æ»‘æ—‹è½¬
                    if (currentState === STATE.SCATTER) {
                        rotationVelocity.y = 0.1;
                        status.innerHTML = "çŠ¶æ€: <span style='color:#ffff00'>å‘å³æ—‹è½¬</span>";
                    }
                    break;
                    
                case GESTURE.SWIPE_LEFT:
                    // å·¦æ»‘æ—‹è½¬
                    if (currentState === STATE.SCATTER) {
                        rotationVelocity.y = -0.1;
                        status.innerHTML = "çŠ¶æ€: <span style='color:#ffff00'>å‘å·¦æ—‹è½¬</span>";
                    }
                    break;
            }
        }

        function selectNearestPhoto() {
            if (photoMeshes.length === 0 || !camera) return;
            
            let nearestIndex = -1;
            let minDistance = Infinity;
            const cameraPos = camera.position;
            
            photoMeshes.forEach((mesh, index) => {
                if (!mesh.visible) return;
                
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                const distance = worldPos.distanceTo(cameraPos);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = index;
                }
            });
            
            if (nearestIndex >= 0) {
                selectPhoto(nearestIndex);
            }
        }

        // --- åŠ¨ç”»æ›´æ–° ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            
            time += 0.016; // åŸºäº60fps
            frameCount++;
            
            if (currentMode === APP_MODE.INTRO && introActive) {
                updateIntro();
            } else if (currentMode === APP_MODE.CAKE) {
                updateInstancedMeshes();
                updateDust();
                updatePhotos();
                updateSnow();
                updateSparkles();
                updateCrown();
                
                // æ–‡å­—åŠ¨ç”»
                if (textMesh) {
                    textMesh.lookAt(camera.position);
                    const targetOpacity = (currentState === STATE.TREE) ? 1.0 : 0.0;
                    textMesh.material.opacity += (targetOpacity - textMesh.material.opacity) * 0.1;
                }
                
                // æ—‹è½¬æ§åˆ¶
                updateRotation();
            }
            
            composer.render();
        }

        function updateIntro() {
            if (introTimelineStep === 0 || !introActive) return;
            
            const now = Date.now();
            const elapsed = now - introTimer;
            
            // å€’è®¡æ—¶æ­¥éª¤
            if (introTimelineStep === 1 && elapsed > 1000) { 
                introTimelineStep = 2; 
                applyTargets("4"); 
                introTimer = now; 
            } else if (introTimelineStep === 2 && elapsed > 1000) { 
                introTimelineStep = 3; 
                applyTargets("3"); 
                introTimer = now; 
            } else if (introTimelineStep === 3 && elapsed > 1000) { 
                introTimelineStep = 4; 
                applyTargets("2"); 
                introTimer = now; 
            } else if (introTimelineStep === 4 && elapsed > 1000) { 
                introTimelineStep = 5; 
                applyTargets("1"); 
                introTimer = now; 
            } else if (introTimelineStep === 5 && elapsed > 1000) { 
                introTimelineStep = 6; 
                applyTargets("2026"); 
                introTimer = now; 
                new TWEEN.Tween(camera.position)
                    .to({z: 160}, 2000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            } else if (introTimelineStep === 6 && elapsed > 2500) { 
                introTimelineStep = 7; 
                triggerWarpEffect(); 
            }
            
            // ç²’å­åŠ¨ç”»
            const positions = introParticles.geometry.attributes.position.array;
            const sizes = introParticles.geometry.attributes.size.array;
            const flash = introParticles.geometry.attributes.flash.array;
            const vels = introParticles.geometry.attributes.velocity.array;
            
            for(let i = 0; i < CONFIG.introParticleCount; i++) {
                const p = introLogic[i];
                
                if (isWarping) {
                    // æ‰­æ›²æ•ˆæœ
                    p.currentPos.x += vels[i * 3];
                    p.currentPos.y += vels[i * 3 + 1];
                    p.currentPos.z += vels[i * 3 + 2];
                    vels[i * 3 + 2] *= 1.05;
                    vels[i * 3] *= 1.01;
                    vels[i * 3 + 1] *= 1.01;
                } else {
                    // å‘ç›®æ ‡ä½ç½®ç§»åŠ¨
                    const lerpFactor = p.speed;
                    p.currentPos.x += (p.targetPos.x - p.currentPos.x) * lerpFactor;
                    p.currentPos.y += (p.targetPos.y - p.currentPos.y) * lerpFactor;
                    p.currentPos.z += (p.targetPos.z - p.currentPos.z) * lerpFactor;
                    
                    // æ·»åŠ éšæœºè¿åŠ¨
                    if (introTimelineStep === 6) {
                        p.currentPos.x += (Math.random() - 0.5) * 0.2;
                        p.currentPos.y += (Math.random() - 0.5) * 0.2;
                    }
                }
                
                positions[i * 3] = p.currentPos.x;
                positions[i * 3 + 1] = p.currentPos.y;
                positions[i * 3 + 2] = p.currentPos.z;
                
                // å¤§å°é—ªçƒ
                sizes[i] = (1.5 + Math.sin(time * 8 + flash[i]) * 0.8) * 
                          (introTimelineStep === 6 ? 1.8 : 1);
            }
            
            introParticles.geometry.attributes.position.needsUpdate = true;
            introParticles.geometry.attributes.size.needsUpdate = true;
        }

        function triggerWarpEffect() {
            isWarping = true;
            const vels = introParticles.geometry.attributes.velocity.array;
            
            for(let i = 0; i < CONFIG.introParticleCount; i++) {
                vels[i * 3] = (Math.random() - 0.5) * 2;
                vels[i * 3 + 1] = (Math.random() - 0.5) * 2;
                vels[i * 3 + 2] = 3.0 + Math.random() * 6.0;
            }
            
            new TWEEN.Tween(camera.position)
                .to({z: 100}, 2000)
                .easing(TWEEN.Easing.Quadratic.In)
                .start();
            
            setTimeout(() => {
                mainGroup.visible = true;
                mainGroup.scale.set(0.001, 0.001, 0.001);
                
                new TWEEN.Tween(mainGroup.scale)
                    .to({x: 1, y: 1, z: 1}, 3500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
                    
                new TWEEN.Tween(mainGroup.rotation)
                    .to({y: 0}, 3500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }, 500);
            
            setTimeout(finishIntro, 1000);
        }

        function finishIntro() {
            new TWEEN.Tween(introParticles.material)
                .to({opacity: 0}, 1000)
                .onComplete(() => {
                    introActive = false;
                    scene.remove(introGroup);
                    introParticles.geometry.dispose();
                    introParticles.material.dispose();
                    introParticles = null;
                    introLogic = [];
                })
                .start();
            
            new TWEEN.Tween(camera.position)
                .to({z: CONFIG.cameraZ}, 2500)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            
            currentMode = APP_MODE.CAKE;
            
            // æ˜¾ç¤ºè›‹ç³•ç…§ç‰‡
            setTimeout(() => {
                photoMeshes.forEach((m, idx) => {
                    if (m) {
                        m.visible = true;
                        m.scale.set(0, 0, 0);
                        new TWEEN.Tween(m.scale)
                            .to({x: 1, y: 1, z: 1}, 1000)
                            .delay(idx * 50)
                            .easing(TWEEN.Easing.Back.Out)
                            .start();
                    }
                });
                
                // åˆ›å»ºæ–°å¹´å¿«ä¹æ–‡å­—
                createNewYearText();
                
                // å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
                setupMediaPipe();
                
            }, 1500);
        }

        function updateInstancedMeshes() {
            const isMobile = window.innerWidth < 768;
            const lerpFactor = isMobile ? 0.2 : 0.1;
            
            // æ›´æ–°æ‰€æœ‰å®ä¾‹åŒ–ç½‘æ ¼
            const meshes = [
                { mesh: goldMesh, data: logicData.gold },
                { mesh: silverMesh, data: logicData.silver },
                { mesh: gemMesh, data: logicData.gem },
                { mesh: emeraldMesh, data: logicData.emerald },
                { mesh: diamondMesh, data: logicData.diamond }
            ];
            
            meshes.forEach(({ mesh, data }) => {
                if (!mesh || !data) return;
                
                for(let i = 0; i < data.length; i++) {
                    const item = data[i];
                    let target = item.scatterPos;
                    
                    if (currentState === STATE.TREE) {
                        target = item.treePos;
                    }
                    
                    // æ·»åŠ æµ®åŠ¨æ•ˆæœ
                    if (currentState === STATE.SCATTER) {
                        item.currentPos.y += Math.sin(time + item.floatOffset) * 0.005;
                    }
                    
                    // å¹³æ»‘ç§»åŠ¨
                    item.currentPos.lerp(target, lerpFactor);
                    
                    // æ—‹è½¬
                    item.rotation.x += item.rotSpeed.x;
                    item.rotation.y += item.rotSpeed.y;
                    item.rotation.z += item.rotSpeed.z;
                    
                    // ç¼©æ”¾
                    let scale = item.scale;
                    if (currentState === STATE.ZOOM) {
                        scale = item.scale * 0.7;
                    } else if (currentState === STATE.SCATTER) {
                        scale = item.scale * (0.9 + Math.sin(time + i) * 0.1);
                    }
                    
                    // æ›´æ–°å®ä¾‹çŸ©é˜µ
                    dummy.position.copy(item.currentPos);
                    dummy.rotation.copy(item.rotation);
                    dummy.scale.setScalar(scale);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                
                mesh.instanceMatrix.needsUpdate = true;
            });
        }

        function updateDust() {
            if (!dustSystem) return;
            
            const isMobile = window.innerWidth < 768;
            const lerpFactor = isMobile ? 0.2 : 0.1;
            const positions = dustSystem.geometry.attributes.position.array;
            
            for(let i = 0; i < logicData.dust.length; i++) {
                const item = logicData.dust[i];
                let target = item.scatterPos;
                
                if (currentState === STATE.TREE) {
                    target = item.treePos;
                    
                    // è›‹ç³•çŠ¶æ€ä¸‹çš„ä¸Šå‡æ•ˆæœ
                    item.currentPos.y += 0.03;
                    const tier = CONFIG.tiers[item.tierIndex];
                    
                    if (item.currentPos.y > tier.yBottom + tier.height) {
                        item.currentPos.y = tier.yBottom;
                    }
                    
                    // é™åˆ¶åŠå¾„
                    const radius = Math.sqrt(item.currentPos.x ** 2 + item.currentPos.z ** 2);
                    if (radius > tier.radius * 1.3) {
                        item.currentPos.x *= 0.99;
                        item.currentPos.z *= 0.99;
                    }
                } else {
                    // æ•£å¼€çŠ¶æ€ä¸‹çš„å¹³æ»‘ç§»åŠ¨
                    item.currentPos.lerp(target, lerpFactor);
                    
                    // æ·»åŠ æµ®åŠ¨
                    item.currentPos.y += Math.sin(time * 2 + item.floatOffset) * 0.01;
                }
                
                positions[i * 3] = item.currentPos.x;
                positions[i * 3 + 1] = item.currentPos.y;
                positions[i * 3 + 2] = item.currentPos.z;
            }
            
            dustSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updateSnow() {
            if (!snowSystem) return;
            
            const positions = snowSystem.geometry.attributes.position.array;
            const sizes = snowSystem.geometry.attributes.size.array;
            const floats = snowSystem.geometry.attributes.float.array;
            const speeds = snowSystem.userData.speeds;
            
            for(let i = 0; i < CONFIG.snowCount; i++) {
                // ä¸‹è½
                positions[i * 3 + 1] -= speeds[i];
                
                // å·¦å³æ‘†åŠ¨
                positions[i * 3] += Math.sin(time * 0.5 + floats[i]) * 0.05;
                
                // å¤§å°å˜åŒ–
                sizes[i] = 1.5 + Math.sin(time * 3 + i) * 0.5;
                
                // å¾ªç¯
                if (positions[i * 3 + 1] < -150) {
                    positions[i * 3 + 1] = 150;
                    positions[i * 3] = (Math.random() - 0.5) * 400;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                }
            }
            
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.geometry.attributes.size.needsUpdate = true;
        }

        function updateSparkles() {
            if (!sparkleSystem) return;
            
            const positions = sparkleSystem.geometry.attributes.position.array;
            const sizes = sparkleSystem.geometry.attributes.size.array;
            const animations = sparkleSystem.geometry.attributes.animation.array;
            
            for(let i = 0; i < CONFIG.sparkleCount; i++) {
                // æ—‹è½¬
                const angle = animations[i] + time * 0.5;
                const radius = Math.sqrt(
                    positions[i * 3] * positions[i * 3] + 
                    positions[i * 3 + 2] * positions[i * 3 + 2]
                );
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // ä¸Šä¸‹æµ®åŠ¨
                positions[i * 3 + 1] += Math.sin(time * 2 + i) * 0.01;
                
                // é—ªçƒ
                sizes[i] = 0.5 + Math.sin(time * 5 + i) * 0.3;
            }
            
            sparkleSystem.geometry.attributes.position.needsUpdate = true;
            sparkleSystem.geometry.attributes.size.needsUpdate = true;
        }

        function updateCrown() {
            if (!logicData.crown) return;
            
            const crown = logicData.crown;
            let target = crown.userData.scatterPos;
            
            if (currentState === STATE.TREE) {
                target = crown.userData.treePos;
            }
            
            crown.position.lerp(target, 0.1);
            
            // æ—‹è½¬
            crown.rotation.y += 0.01;
            
            // ä¸Šä¸‹æµ®åŠ¨
            crown.position.y += Math.sin(time) * 0.02;
        }

        function updatePhotos() {
            const isMobile = window.innerWidth < 768;
            const lerpFactor = isMobile ? 0.2 : 0.1;
            
            photoMeshes.forEach((mesh, idx) => {
                if (!mesh.visible) return;
                
                let targetPos, targetScale, targetRot;
                
                switch(currentState) {
                    case STATE.TREE:
                        targetPos = mesh.userData.treePos;
                        targetScale = CONFIG.photoScale.tree;
                        targetRot = mesh.userData.baseRot;
                        break;
                        
                    case STATE.SCATTER:
                        targetPos = mesh.userData.scatterPos;
                        targetScale = CONFIG.photoScale.scatter;
                        
                        // é¢å‘ç›¸æœº
                        mesh.lookAt(camera.position);
                        targetRot = mesh.rotation;
                        
                        // æµ®åŠ¨æ•ˆæœ
                        mesh.position.y += Math.sin(time * 0.5 + idx) * 0.01;
                        break;
                        
                    case STATE.ZOOM:
                        if (idx === zoomPhotoIndex) {
                            // æ”¾å¤§åˆ°ç›¸æœºå‰æ–¹
                            const offset = new THREE.Vector3(0, 0, -25);
                            offset.applyMatrix4(camera.matrixWorld);
                            targetPos = mainGroup.worldToLocal(offset);
                            targetScale = CONFIG.photoScale.zoom;
                            
                            // é¢å‘ç›¸æœº
                            mesh.lookAt(camera.position);
                            targetRot = mesh.rotation;
                            
                            // å¢å¼ºå‘å…‰
                            mesh.material.emissiveIntensity = 1.0;
                        } else {
                            targetPos = mesh.userData.scatterPos;
                            targetScale = CONFIG.photoScale.scatter * 0.7;
                            mesh.lookAt(camera.position);
                            targetRot = mesh.rotation;
                            mesh.material.emissiveIntensity = mesh.userData.originalEmissiveIntensity;
                        }
                        break;
                }
                
                // å¹³æ»‘ç§»åŠ¨å’Œç¼©æ”¾
                mesh.position.lerp(targetPos, lerpFactor);
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpFactor);
                
                if (targetRot) {
                    mesh.rotation.x += (targetRot.x - mesh.rotation.x) * lerpFactor;
                    mesh.rotation.y += (targetRot.y - mesh.rotation.y) * lerpFactor;
                    mesh.rotation.z += (targetRot.z - mesh.rotation.z) * lerpFactor;
                }
                
                // é«˜äº®åŠ¨ç”»
                if (mesh.userData.highlightMesh) {
                    const highlightMat = mesh.userData.highlightMesh.material;
                    if (idx === selectedPhotoIndex) {
                        highlightMat.opacity = 0.3 + Math.sin(time * 3) * 0.1;
                    }
                }
            });
        }

        function updateRotation() {
            if (currentState === STATE.SCATTER) {
                // é™åˆ¶æ—‹è½¬é€Ÿåº¦
                rotationVelocity.y = Math.min(Math.max(rotationVelocity.y, -0.15), 0.15);
                rotationVelocity.x = Math.min(Math.max(rotationVelocity.x, -0.08), 0.08);
                
                // åº”ç”¨æ—‹è½¬
                mainGroup.rotation.y += rotationVelocity.y;
                mainGroup.rotation.x += rotationVelocity.x;
                
                // é˜»å°¼
                rotationVelocity.y *= 0.96;
                rotationVelocity.x *= 0.92;
                
                // é™åˆ¶Xè½´æ—‹è½¬
                mainGroup.rotation.x = Math.min(Math.max(mainGroup.rotation.x, -0.5), 0.5);
            } else if (currentState === STATE.TREE) {
                // è›‹ç³•çŠ¶æ€ç¼“æ…¢è‡ªè½¬
                mainGroup.rotation.y += 0.002;
                mainGroup.rotation.x *= 0.98; // æ¢å¤æ°´å¹³
            }
        }

        // --- çª—å£å¤§å°è°ƒæ•´ ---
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            if (camera) {
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            
            if (renderer) {
                renderer.setSize(width, height);
            }
            
            if (composer) {
                composer.setSize(width, height);
                if (composer.passes[1]) {
                    composer.passes[1].resolution.set(width, height);
                }
            }
            
            // è°ƒæ•´ç›¸æœºè·ç¦»
            if (currentMode === APP_MODE.CAKE && camera) {
                const isPortrait = height > width;
                const targetZ = isPortrait ? 180 : 140;
                
                new TWEEN.Tween(camera.position)
                    .to({z: targetZ}, 500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }
        }

        // --- é¡µé¢å¯è§æ€§å¤„ç† ---
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") {
                // é¡µé¢æ¢å¤å¯è§
                if (video && video.paused && isCameraActive) {
                    video.play().catch(e => {
                        console.log("è§†é¢‘æ¢å¤æ’­æ”¾å¤±è´¥:", e);
                    });
                }
                
                if (bgm.paused) {
                    bgm.play().catch(e => {
                        console.log("éŸ³ä¹æ¢å¤æ’­æ”¾å¤±è´¥:", e);
                    });
                }
            } else {
                // é¡µé¢éšè—
                if (!bgm.paused) {
                    bgm.pause();
                }
            }
        });

        // --- é”™è¯¯å¤„ç† ---
        window.addEventListener('error', (event) => {
            console.error('å…¨å±€é”™è¯¯:', event.error);
            
            // æ˜¾ç¤ºå‹å¥½é”™è¯¯ä¿¡æ¯
            const statusText = document.getElementById('status-text');
            if (statusText) {
                statusText.innerHTML = "ç³»ç»Ÿé‡åˆ°é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢";
                statusText.style.color = "#ff4444";
            }
        });

        // --- åˆå§‹åŒ– ---
        initThree();

        // --- å¯¼å‡ºå‡½æ•°ä¾›HTMLè°ƒç”¨ ---
        window.setupMediaPipe = setupMediaPipe;
        window.toggleVideoSize = toggleVideoSize;
        window.closePhotoDetail = closePhotoDetail;
        
        // å…¨å±€è®¿é—®
        window.APP = {
            config: CONFIG,
            state: {
                currentMode,
                currentState,
                selectedPhotoIndex,
                isPhotoDetailOpen
            },
            functions: {
                openPhotoDetail,
                selectPhoto,
                setupMediaPipe
            }
        };
        
        console.log("2026è·¨å¹´ç››å…¸ - å¸ç‹è±ªåå®Œå…¨ä½“ V9 å·²åŠ è½½");

    </script>
</body>
</html>
