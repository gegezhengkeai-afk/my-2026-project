<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dè›‹ç³•å›¾ç‰‡é•¶åµŒç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c0c0e 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            width: 320px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .title-section {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .title-section h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .title-section p {
            color: #a0a0c0;
            font-size: 0.95rem;
        }
        
        .control-section {
            margin: 20px 0;
        }
        
        .control-title {
            color: #ffd700;
            font-size: 1.1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .control-btn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 195, 0, 0.8));
            color: #1a1a2e;
            border: none;
            padding: 12px 15px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.95rem;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .info-section {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            border-left: 3px solid #ffd700;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            color: #c0c0e0;
            font-size: 0.9rem;
        }
        
        .info-label {
            font-weight: bold;
        }
        
        .info-value {
            color: #ffd700;
        }
        
        .instructions {
            background: rgba(30, 30, 50, 0.6);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        
        .instruction-item {
            display: flex;
            align-items: flex-start;
            margin: 10px 0;
            color: #b0b0d0;
        }
        
        .instruction-icon {
            margin-right: 10px;
            color: #ffd700;
            font-size: 1rem;
            min-width: 20px;
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.8s ease;
        }
        
        .loading-content {
            text-align: center;
            max-width: 500px;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(255, 215, 0, 0.1);
            border-radius: 50%;
            border-top-color: #ffd700;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }
        
        .loading-subtitle {
            color: #a0a0c0;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }
        
        .progress-bar {
            width: 300px;
            height: 6px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 20px auto;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-details {
            color: #8888aa;
            font-size: 0.9rem;
            margin-top: 20px;
        }
        
        #photoCounter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 1000;
            border: 1px solid rgba(255, 215, 0, 0.2);
            text-align: center;
        }
        
        .counter-number {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .counter-label {
            color: #a0a0c0;
            font-size: 0.9rem;
        }
        
        .debug-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #90ff90;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            font-family: monospace;
            z-index: 1000;
            max-width: 300px;
            display: none;
        }
        
        @media (max-width: 768px) {
            #ui-panel {
                width: calc(100% - 40px);
                max-width: 320px;
                padding: 20px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .glow-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255, 215, 0, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
</head>
<body>
    <div id="container"></div>
    <div class="glow-effect"></div>
    
    <div id="ui-panel">
        <div class="title-section">
            <h1>ğŸ‚ 3Dè›‹ç³•å›¾ç‰‡é•¶åµŒç³»ç»Ÿ</h1>
            <p>å°†GitHubä»“åº“ä¸­çš„å›¾ç‰‡é•¶åµŒåœ¨3Dè›‹ç³•ä¸­</p>
        </div>
        
        <div class="control-section">
            <div class="control-title">ğŸ® äº¤äº’æ§åˆ¶</div>
            <div class="control-grid">
                <button class="control-btn" id="scatterBtn">
                    <span>ğŸ¯</span> æ•£å¼€å›¾ç‰‡
                </button>
                <button class="control-btn" id="resetBtn">
                    <span>ğŸ‚</span> å½’ä½å›¾ç‰‡
                </button>
                <button class="control-btn" id="rotateBtn">
                    <span>ğŸ”„</span> æ—‹è½¬è›‹ç³•
                </button>
                <button class="control-btn" id="lightingBtn">
                    <span>ğŸ’¡</span> åˆ‡æ¢ç¯å…‰
                </button>
            </div>
        </div>
        
        <div class="info-section">
            <div class="info-item">
                <span class="info-label">å›¾ç‰‡æ€»æ•°:</span>
                <span class="info-value" id="totalPhotos">13</span>
            </div>
            <div class="info-item">
                <span class="info-label">å·²åŠ è½½:</span>
                <span class="info-value" id="loadedPhotos">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">è›‹ç³•å±‚çº§:</span>
                <span class="info-value">3å±‚</span>
            </div>
            <div class="info-item">
                <span class="info-label">çŠ¶æ€:</span>
                <span class="info-value" id="systemStatus">åˆå§‹åŒ–ä¸­...</span>
            </div>
        </div>
        
        <div class="instructions">
            <div class="instruction-item">
                <span class="instruction-icon">ğŸ–±ï¸</span>
                <span>é¼ æ ‡æ‹–æ‹½ - æ—‹è½¬è§†è§’</span>
            </div>
            <div class="instruction-item">
                <span class="instruction-icon">ğŸ¯</span>
                <span>æ»šè½®ç¼©æ”¾ - è°ƒæ•´è¿œè¿‘</span>
            </div>
            <div class="instruction-item">
                <span class="instruction-icon">ğŸ‘†</span>
                <span>ç‚¹å‡»å›¾ç‰‡ - æŸ¥çœ‹å¤§å›¾</span>
            </div>
            <div class="instruction-item">
                <span class="instruction-icon">âš™ï¸</span>
                <span>ä½¿ç”¨æ§åˆ¶æŒ‰é’®ç®¡ç†åœºæ™¯</span>
            </div>
        </div>
    </div>
    
    <div id="photoCounter">
        <div class="counter-number" id="counterNumber">0</div>
        <div class="counter-label">å·²åŠ è½½å›¾ç‰‡</div>
    </div>
    
    <div class="debug-info" id="debugInfo"></div>
    
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-content">
            <div class="loader"></div>
            <div class="loading-title">3Dè›‹ç³•å›¾ç‰‡ç³»ç»Ÿ</div>
            <div class="loading-subtitle">æ­£åœ¨ä»GitHubä»“åº“åŠ è½½å›¾ç‰‡...</div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="loading-details" id="loadingDetails">
                å‡†å¤‡å¯åŠ¨3Dæ¸²æŸ“å¼•æ“...
            </div>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€é…ç½® ====================
        const CONFIG = {
            // è›‹ç³•å±‚çº§é…ç½®
            tiers: [
                { radius: 28, height: 16, yBottom: 0, color: 0xf8c8dc, name: "åº•å±‚", photoCount: 6 },
                { radius: 20, height: 14, yBottom: 16, color: 0xffb6c1, name: "ä¸­å±‚", photoCount: 4 },
                { radius: 14, height: 12, yBottom: 30, color: 0xff69b4, name: "é¡¶å±‚", photoCount: 3 }
            ],
            
            // å›¾ç‰‡é…ç½®
            photoConfig: {
                baseSize: 6,                    // ç…§ç‰‡åŸºæœ¬å°ºå¯¸
                frameThickness: 0.25,           // ç›¸æ¡†åšåº¦
                frameColor: 0xffd700,          // ç›¸æ¡†é¢œè‰²ï¼ˆé‡‘è‰²ï¼‰
                emissiveIntensity: 0.4,         // è‡ªå‘å…‰å¼ºåº¦
                maxPhotos: 13                   // æ€»å›¾ç‰‡æ•°é‡
            },
            
            // åŠ¨ç”»é…ç½®
            animation: {
                scatterSpeed: 0.03,             // æ•£å¼€åŠ¨ç”»é€Ÿåº¦
                resetSpeed: 0.05,               // å½’ä½åŠ¨ç”»é€Ÿåº¦
                rotationSpeed: 0.005,           // è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦
                hoverSpeed: 0.1                 // æ‚¬åœåŠ¨ç”»é€Ÿåº¦
            },
            
            // åœºæ™¯é…ç½®
            scene: {
                backgroundColor: 0x0a0a1a,      // èƒŒæ™¯é¢œè‰²
                fogColor: 0x0a0a1a,             // é›¾æ•ˆé¢œè‰²
                fogNear: 50,                    // é›¾æ•ˆèµ·å§‹è·ç¦»
                fogFar: 200                     // é›¾æ•ˆç»“æŸè·ç¦»
            },
            
            // GitHubä»“åº“é…ç½®
            github: {
                username: 'gsgszhengkeai-afk',
                repoName: 'my-2026-project',
                branch: 'main',
                imagePath: 'images'
            }
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, controls, composer;
        let mainGroup, photoGroup, cakeGroup;
        let photoMeshes = [];
        let isScattered = false;
        let isRotating = true;
        let currentLighting = 'default';
        let bloomPass, renderPass;
        
        // å›¾ç‰‡è·¯å¾„æ•°ç»„
        let IMAGE_PATHS = [];
        for(let i = 1; i <= CONFIG.photoConfig.maxPhotos; i++) {
            const path = `https://raw.githubusercontent.com/${CONFIG.github.username}/${CONFIG.github.repoName}/${CONFIG.github.branch}/${CONFIG.github.imagePath}/${i}.jpg`;
            IMAGE_PATHS.push(path);
        }
        
        // ==================== åˆå§‹åŒ–å‡½æ•° ====================
        function init() {
            // æ›´æ–°åŠ è½½çŠ¶æ€
            updateLoadingStatus('åˆå§‹åŒ–3Dåœºæ™¯...', 10);
            
            // åˆ›å»ºThree.jsåœºæ™¯
            createScene();
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            createRenderer();
            
            // è®¾ç½®ç›¸æœº
            createCamera();
            
            // æ·»åŠ è½¨é“æ§åˆ¶
            createControls();
            
            // æ·»åŠ ç¯å…‰
            createLights();
            
            // åˆ›å»ºè›‹ç³•æ¨¡å‹
            createCakeModel();
            
            // åˆ›å»ºå›¾ç‰‡ç»„
            createPhotoGroup();
            
            // åŠ è½½å¹¶é•¶åµŒå›¾ç‰‡
            loadAndInlayPhotos();
            
            // æ·»åŠ åæœŸå¤„ç†æ•ˆæœ
            createPostProcessing();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        // ==================== åœºæ™¯åˆ›å»ºå‡½æ•° ====================
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.scene.backgroundColor);
            scene.fog = new THREE.Fog(CONFIG.scene.fogColor, CONFIG.scene.fogNear, CONFIG.scene.fogFar);
            
            // åˆ›å»ºä¸»ç»„
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            // åˆ›å»ºè›‹ç³•ç»„
            cakeGroup = new THREE.Group();
            mainGroup.add(cakeGroup);
            
            updateLoadingStatus('åœºæ™¯åˆ›å»ºå®Œæˆ', 20);
        }
        
        function createRenderer() {
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('container').appendChild(renderer.domElement);
            
            updateLoadingStatus('æ¸²æŸ“å™¨åˆ›å»ºå®Œæˆ', 30);
        }
        
        function createCamera() {
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(45, 35, 45);
            camera.lookAt(0, 15, 0);
            
            updateLoadingStatus('ç›¸æœºè®¾ç½®å®Œæˆ', 40);
        }
        
        function createControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.minDistance = 25;
            controls.maxDistance = 150;
            controls.maxPolarAngle = Math.PI / 2;
            controls.enablePan = true;
            
            updateLoadingStatus('äº¤äº’æ§åˆ¶åˆå§‹åŒ–', 50);
        }
        
        function createLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // ä¸»æ–¹å‘å…‰
            const mainLight = new THREE.DirectionalLight(0xfff0e6, 0.8);
            mainLight.position.set(30, 60, 30);
            mainLight.castShadow = true;
            mainLight.shadow.camera.left = -60;
            mainLight.shadow.camera.right = 60;
            mainLight.shadow.camera.top = 60;
            mainLight.shadow.camera.bottom = -60;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);
            
            // è¡¥å…‰
            const fillLight = new THREE.DirectionalLight(0x6699ff, 0.3);
            fillLight.position.set(-30, 40, -30);
            scene.add(fillLight);
            
            // èšå…‰ç¯ï¼ˆç…§äº®è›‹ç³•ï¼‰
            const spotLight = new THREE.SpotLight(0xffd700, 0.6, 150, Math.PI / 6, 0.5, 2);
            spotLight.position.set(0, 80, 0);
            spotLight.target.position.set(0, 0, 0);
            spotLight.castShadow = true;
            scene.add(spotLight);
            scene.add(spotLight.target);
            
            // ç‚¹å…‰æºï¼ˆè£…é¥°æ€§ï¼‰
            const pointLight1 = new THREE.PointLight(0xff4444, 0.5, 50);
            pointLight1.position.set(40, 20, 40);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4444ff, 0.5, 50);
            pointLight2.position.set(-40, 20, -40);
            scene.add(pointLight2);
            
            updateLoadingStatus('ç¯å…‰ç³»ç»Ÿé…ç½®å®Œæˆ', 60);
        }
        
        // ==================== è›‹ç³•åˆ›å»ºå‡½æ•° ====================
        function createCakeModel() {
            // è›‹ç³•åº•åº§
            const baseGeometry = new THREE.CylinderGeometry(32, 32, 3, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513,
                roughness: 0.8,
                metalness: 0.3
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -1.5;
            base.castShadow = true;
            base.receiveShadow = true;
            cakeGroup.add(base);
            
            // åº•åº§è¾¹ç¼˜è£…é¥°
            const baseTrimGeometry = new THREE.TorusGeometry(32.5, 0.8, 8, 64);
            const baseTrimMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.9
            });
            const baseTrim = new THREE.Mesh(baseTrimGeometry, baseTrimMaterial);
            baseTrim.position.y = -1.5;
            baseTrim.rotation.x = Math.PI / 2;
            cakeGroup.add(baseTrim);
            
            // åˆ›å»ºè›‹ç³•å±‚çº§
            CONFIG.tiers.forEach((tier, tierIndex) => {
                // è›‹ç³•ä¸»ä½“
                const cakeGeometry = new THREE.CylinderGeometry(tier.radius, tier.radius, tier.height, 64);
                const cakeMaterial = new THREE.MeshStandardMaterial({ 
                    color: tier.color,
                    roughness: 0.2,
                    metalness: 0.1
                });
                const cake = new THREE.Mesh(cakeGeometry, cakeMaterial);
                cake.position.y = tier.yBottom + tier.height / 2;
                cake.castShadow = true;
                cake.receiveShadow = true;
                cakeGroup.add(cake);
                
                // è›‹ç³•è¾¹ç¼˜è£…é¥°
                const trimGeometry = new THREE.TorusGeometry(tier.radius + 0.3, 0.6, 8, 64);
                const trimMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700,
                    roughness: 0.1,
                    metalness: 1.0,
                    emissive: 0x333300,
                    emissiveIntensity: 0.2
                });
                const trim = new THREE.Mesh(trimGeometry, trimMaterial);
                trim.position.y = tier.yBottom + tier.height;
                trim.rotation.x = Math.PI / 2;
                cakeGroup.add(trim);
                
                // å¦‚æœæ˜¯æœ€ä¸Šå±‚ï¼Œæ·»åŠ èœ¡çƒ›
                if (tierIndex === CONFIG.tiers.length - 1) {
                    // èœ¡çƒ›
                    const candleGeometry = new THREE.CylinderGeometry(0.7, 0.7, 10, 16);
                    const candleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff4444,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3
                    });
                    const candle = new THREE.Mesh(candleGeometry, candleMaterial);
                    candle.position.set(0, tier.yBottom + tier.height + 5, 0);
                    cakeGroup.add(candle);
                    
                    // ç«ç„°
                    const flameGeometry = new THREE.ConeGeometry(1.2, 3, 16);
                    const flameMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.9
                    });
                    const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                    flame.position.set(0, tier.yBottom + tier.height + 11, 0);
                    cakeGroup.add(flame);
                    
                    // ç«ç„°åŠ¨ç”»
                    flame.userData = { baseY: tier.yBottom + tier.height + 11 };
                }
            });
            
            updateLoadingStatus('è›‹ç³•æ¨¡å‹åˆ›å»ºå®Œæˆ', 70);
        }
        
        // ==================== å›¾ç‰‡å¤„ç†å‡½æ•° ====================
        function createPhotoGroup() {
            photoGroup = new THREE.Group();
            mainGroup.add(photoGroup);
        }
        
        function loadAndInlayPhotos() {
            const loader = new THREE.TextureLoader();
            let loadedCount = 0;
            
            // æŒ‰å±‚çº§åˆ†é…å›¾ç‰‡
            let photoIndex = 0;
            
            CONFIG.tiers.forEach((tier, tierIndex) => {
                for (let i = 0; i < tier.photoCount; i++) {
                    if (photoIndex >= IMAGE_PATHS.length) break;
                    
                    const path = IMAGE_PATHS[photoIndex];
                    loader.load(
                        path,
                        // åŠ è½½æˆåŠŸå›è°ƒ
                        (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            
                            // è®¡ç®—ç…§ç‰‡å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                            const aspectRatio = texture.image.width / texture.image.height;
                            const width = CONFIG.photoConfig.baseSize;
                            const height = CONFIG.photoConfig.baseSize / aspectRatio;
                            
                            // åˆ›å»ºç…§ç‰‡ç½‘æ ¼
                            createPhotoMesh(texture, width, height, photoIndex, tierIndex, i);
                            
                            loadedCount++;
                            updatePhotoLoadingProgress(loadedCount);
                            
                            if (loadedCount === CONFIG.photoConfig.maxPhotos) {
                                updateLoadingStatus('æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ', 95);
                                setTimeout(() => {
                                    completeLoading();
                                }, 1000);
                            }
                        },
                        // åŠ è½½è¿›åº¦å›è°ƒ
                        (xhr) => {
                            const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                            updateLoadingDetails(`åŠ è½½å›¾ç‰‡ ${photoIndex + 1}/${CONFIG.photoConfig.maxPhotos}: ${percent}%`);
                        },
                        // åŠ è½½å¤±è´¥å›è°ƒ
                        (error) => {
                            console.error(`æ— æ³•åŠ è½½å›¾ç‰‡: ${path}`, error);
                            // åˆ›å»ºæ›¿ä»£å›¾ç‰‡
                            createPlaceholderPhoto(photoIndex, tierIndex, i);
                            loadedCount++;
                            updatePhotoLoadingProgress(loadedCount);
                            
                            if (loadedCount === CONFIG.photoConfig.maxPhotos) {
                                updateLoadingStatus('æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ', 95);
                                setTimeout(() => {
                                    completeLoading();
                                }, 1000);
                            }
                        }
                    );
                    
                    photoIndex++;
                }
            });
            
            updateLoadingStatus('å¼€å§‹åŠ è½½å›¾ç‰‡...', 80);
        }
        
        function createPhotoMesh(texture, width, height, photoIdx, tierIdx, tierPhotoIdx) {
            // 1. åˆ›å»ºç…§ç‰‡å¹³é¢
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture,
                side: THREE.DoubleSide,
                emissive: 0x222222,
                emissiveIntensity: CONFIG.photoConfig.emissiveIntensity,
                roughness: 0.4,
                metalness: 0.1
            });
            const photoMesh = new THREE.Mesh(geometry, material);
            
            // 2. åˆ›å»ºç›¸æ¡†
            const frameGeometry = new THREE.BoxGeometry(
                width + CONFIG.photoConfig.frameThickness * 2, 
                height + CONFIG.photoConfig.frameThickness * 2, 
                CONFIG.photoConfig.frameThickness
            );
            const frameMaterial = new THREE.MeshPhysicalMaterial({ 
                color: CONFIG.photoConfig.frameColor,
                metalness: 0.95,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05,
                emissive: 0x333300,
                emissiveIntensity: 0.1
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.z = -CONFIG.photoConfig.frameThickness / 2;
            photoMesh.add(frame);
            
            // 3. è®¡ç®—é•¶åµŒä½ç½®
            const tier = CONFIG.tiers[tierIdx];
            
            // è®¡ç®—è§’åº¦ï¼ˆåœ¨å±‚çº§å†…å¹³å‡åˆ†å¸ƒï¼‰
            const angle = (tierPhotoIdx / tier.photoCount) * Math.PI * 2;
            
            // æ·»åŠ å±‚çº§è§’åº¦åç§»ï¼Œä½¿å„å±‚ç…§ç‰‡é”™å¼€
            const tierAngleOffset = tierIdx * Math.PI / 8;
            const finalAngle = angle + tierAngleOffset;
            
            // è®¡ç®—åŠå¾„ï¼šè›‹ç³•åŠå¾„ + å›¾ç‰‡é—´è·
            const radius = tier.radius + 2.5;
            
            // è®¡ç®—ç…§ç‰‡ä½ç½®
            const treePos = new THREE.Vector3(
                radius * Math.cos(finalAngle),
                tier.yBottom + (tier.height / 2),
                radius * Math.sin(finalAngle)
            );
            
            // 4. è®¾ç½®ç…§ç‰‡å±æ€§
            photoMesh.userData = {
                id: photoIdx,
                treePos: treePos,
                scatterPos: generateScatterPosition(photoIdx),
                initialAngle: finalAngle,
                tier: tierIdx,
                originalWidth: width,
                originalHeight: height,
                isHovered: false,
                isSelected: false
            };
            
            // 5. åº”ç”¨ä½ç½®å’Œæœå‘
            photoMesh.position.copy(treePos);
            
            // è®©ç…§ç‰‡æœå‘è›‹ç³•ä¸­å¿ƒ
            photoMesh.lookAt(0, photoMesh.position.y, 0);
            
            // ç¿»è½¬180åº¦ä½¿ç…§ç‰‡æ­£é¢æœå¤–
            photoMesh.rotateY(Math.PI);
            
            // æ·»åŠ è½»å¾®éšæœºå€¾æ–œ
            photoMesh.rotateZ((Math.random() - 0.5) * 0.15);
            photoMesh.rotateX((Math.random() - 0.5) * 0.1);
            
            // 6. æ·»åŠ åˆ°åœºæ™¯
            photoGroup.add(photoMesh);
            photoMeshes.push(photoMesh);
            
            // 7. æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬
            photoMesh.userData.onClick = function() {
                handlePhotoClick(photoIdx);
            };
            
            return photoMesh;
        }
        
        function createPlaceholderPhoto(photoIdx, tierIdx, tierPhotoIdx) {
            // åˆ›å»ºæ›¿ä»£çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // ç»˜åˆ¶æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // ç»˜åˆ¶å›¾æ ‡
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ“·', 256, 256);
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = '#a0a0c0';
            ctx.font = '24px Arial';
            ctx.fillText(`å›¾ç‰‡ ${photoIdx + 1}`, 256, 350);
            ctx.fillText('åŠ è½½å¤±è´¥', 256, 380);
            
            // åˆ›å»ºçº¹ç†
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            
            // ä½¿ç”¨é€šç”¨å‡½æ•°åˆ›å»ºç½‘æ ¼
            return createPhotoMesh(texture, CONFIG.photoConfig.baseSize, CONFIG.photoConfig.baseSize, photoIdx, tierIdx, tierPhotoIdx);
        }
        
        function generateScatterPosition(photoIdx) {
            // ç”Ÿæˆæ•£å¼€ä½ç½®
            const angle = (photoIdx / CONFIG.photoConfig.maxPhotos) * Math.PI * 2;
            const distance = 60 + Math.random() * 40;
            const height = 30 + Math.random() * 40;
            
            return new THREE.Vector3(
                Math.cos(angle) * distance,
                height,
                Math.sin(angle) * distance
            );
        }
        
        // ==================== åæœŸå¤„ç† ====================
        function createPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            
            renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,    // å¼ºåº¦
                0.4,    // åŠå¾„
                0.85    // é˜ˆå€¼
            );
            composer.addPass(bloomPass);
            
            updateLoadingStatus('åæœŸå¤„ç†æ•ˆæœåŠ è½½', 90);
        }
        
        // ==================== äº‹ä»¶å¤„ç† ====================
        function setupEventListeners() {
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // æ§åˆ¶æŒ‰é’®
            document.getElementById('scatterBtn').addEventListener('click', scatterPhotos);
            document.getElementById('resetBtn').addEventListener('click', resetPhotos);
            document.getElementById('rotateBtn').addEventListener('click', toggleRotation);
            document.getElementById('lightingBtn').addEventListener('click', toggleLighting);
            
            // é¼ æ ‡äº‹ä»¶
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            updateLoadingStatus('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®', 92);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onCanvasClick(event) {
            // å®ç°å°„çº¿æ£€æµ‹ï¼Œç‚¹å‡»ç…§ç‰‡
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(photoMeshes, true);
            
            if (intersects.length > 0) {
                const photoMesh = intersects[0].object.parent || intersects[0].object;
                if (photoMesh.userData && photoMesh.userData.onClick) {
                    photoMesh.userData.onClick();
                }
            }
        }
        
        function onMouseMove(event) {
            // æ›´æ–°é¼ æ ‡ä½ç½®ç”¨äºæ‚¬åœæ•ˆæœ
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            
            const intersects = raycaster.intersectObjects(photoMeshes, true);
            
            // é‡ç½®æ‰€æœ‰ç…§ç‰‡çš„æ‚¬åœçŠ¶æ€
            photoMeshes.forEach(mesh => {
                if (mesh.userData) {
                    mesh.userData.isHovered = false;
                    // æ¢å¤åŸå§‹å°ºå¯¸
                    mesh.scale.set(1, 1, 1);
                }
            });
            
            // è®¾ç½®æ‚¬åœçš„ç…§ç‰‡
            if (intersects.length > 0) {
                const photoMesh = intersects[0].object.parent || intersects[0].object;
                if (photoMesh.userData) {
                    photoMesh.userData.isHovered = true;
                    // æ‚¬åœæ—¶ç¨å¾®æ”¾å¤§
                    photoMesh.scale.set(1.05, 1.05, 1.05);
                }
            }
        }
        
        function handlePhotoClick(photoId) {
            console.log(`ç‚¹å‡»äº†ç…§ç‰‡ ${photoId + 1}`);
            // è¿™é‡Œå¯ä»¥æ·»åŠ ç…§ç‰‡ç‚¹å‡»åçš„å¤„ç†é€»è¾‘ï¼Œæ¯”å¦‚æ˜¾ç¤ºå¤§å›¾ç­‰
            alert(`æ‚¨ç‚¹å‡»äº†ç…§ç‰‡ ${photoId + 1}\nå¯ä»¥ä»GitHubä»“åº“æŸ¥çœ‹åŸå›¾`);
        }
        
        // ==================== åŠ¨ç”»æ§åˆ¶å‡½æ•° ====================
        function scatterPhotos() {
            if (isScattered) return;
            isScattered = true;
            updateSystemStatus('å›¾ç‰‡æ•£å¼€ä¸­...');
            
            photoMeshes.forEach((mesh, idx) => {
                if (mesh.userData) {
                    mesh.userData.targetPos = mesh.userData.scatterPos.clone();
                    mesh.userData.targetRotation = new THREE.Euler(
                        Math.random() * Math.PI * 0.5,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI * 0.5
                    );
                }
            });
        }
        
        function resetPhotos() {
            isScattered = false;
            updateSystemStatus('å›¾ç‰‡å½’ä½ä¸­...');
            
            photoMeshes.forEach(mesh => {
                if (mesh.userData) {
                    mesh.userData.targetPos = mesh.userData.treePos.clone();
                    mesh.userData.targetRotation = new THREE.Euler(0, mesh.userData.initialAngle + Math.PI, 0);
                }
            });
        }
        
        function toggleRotation() {
            isRotating = !isRotating;
            updateSystemStatus(isRotating ? 'è›‹ç³•æ—‹è½¬ä¸­' : 'è›‹ç³•æ—‹è½¬å·²åœæ­¢');
            document.getElementById('rotateBtn').innerHTML = isRotating ? '<span>â¸ï¸</span> åœæ­¢æ—‹è½¬' : '<span>ğŸ”„</span> æ—‹è½¬è›‹ç³•';
        }
        
        function toggleLighting() {
            const lights = {
                'default': 'æµªæ¼«ç¯å…‰',
                'romantic': 'æ˜äº®ç¯å…‰',
                'bright': 'éœ“è™¹ç¯å…‰',
                'neon': 'é»˜è®¤ç¯å…‰'
            };
            
            const sequences = ['default', 'romantic', 'bright', 'neon'];
            const currentIndex = sequences.indexOf(currentLighting);
            currentLighting = sequences[(currentIndex + 1) % sequences.length];
            
            updateLighting(currentLighting);
            updateSystemStatus(`ç¯å…‰æ¨¡å¼: ${lights[currentLighting]}`);
        }
        
        function updateLighting(mode) {
            // æ ¹æ®æ¨¡å¼è°ƒæ•´ç¯å…‰
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ç¯å…‰å‚æ•°
            switch(mode) {
                case 'romantic':
                    scene.children.forEach(child => {
                        if (child.isLight && child.type === 'AmbientLight') {
                            child.intensity = 0.3;
                        }
                        if (child.isLight && child.type === 'DirectionalLight') {
                            child.intensity = 0.6;
                            child.color.setHex(0xffe6cc);
                        }
                    });
                    break;
                case 'bright':
                    scene.children.forEach(child => {
                        if (child.isLight && child.type === 'AmbientLight') {
                            child.intensity = 0.8;
                        }
                        if (child.isLight && child.type === 'DirectionalLight') {
                            child.intensity = 1.0;
                            child.color.setHex(0xffffff);
                        }
                    });
                    break;
                case 'neon':
                    scene.children.forEach(child => {
                        if (child.isLight && child.type === 'AmbientLight') {
                            child.intensity = 0.2;
                        }
                        if (child.isLight && child.type === 'DirectionalLight') {
                            child.intensity = 0.5;
                            child.color.setHex(0x00ffff);
                        }
                    });
                    break;
                default:
                    // æ¢å¤é»˜è®¤
                    scene.children.forEach(child => {
                        if (child.isLight && child.type === 'AmbientLight') {
                            child.intensity = 0.5;
                        }
                        if (child.isLight && child.type === 'DirectionalLight') {
                            child.intensity = 0.8;
                            child.color.setHex(0xfff0e6);
                        }
                    });
            }
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            // æ§åˆ¶æ›´æ–°
            if (controls) controls.update();
            
            // è›‹ç³•è‡ªåŠ¨æ—‹è½¬
            if (isRotating) {
                cakeGroup.rotation.y += CONFIG.animation.rotationSpeed;
            }
            
            // ç…§ç‰‡åŠ¨ç”»
            photoMeshes.forEach((mesh, idx) => {
                if (mesh.userData && mesh.userData.targetPos) {
                    // ä½ç½®æ’å€¼
                    mesh.position.lerp(mesh.userData.targetPos, 
                        isScattered ? CONFIG.animation.scatterSpeed : CONFIG.animation.resetSpeed);
                    
                    // æ—‹è½¬æ’å€¼
                    if (mesh.userData.targetRotation) {
                        mesh.rotation.x += (mesh.userData.targetRotation.x - mesh.rotation.x) * 0.05;
                        mesh.rotation.y += (mesh.userData.targetRotation.y - mesh.rotation.y) * 0.05;
                        mesh.rotation.z += (mesh.userData.targetRotation.z - mesh.rotation.z) * 0.05;
                    }
                    
                    // æ‚¬åœåŠ¨ç”»
                    if (mesh.userData.isHovered) {
                        mesh.position.y += Math.sin(Date.now() * 0.005 + idx) * 0.05;
                    }
                }
            });
            
            // ç«ç„°åŠ¨ç”»
            cakeGroup.children.forEach(child => {
                if (child.userData && child.userData.baseY) {
                    child.position.y = child.userData.baseY + Math.sin(Date.now() * 0.005) * 0.3;
                }
            });
            
            // æ¸²æŸ“åœºæ™¯
            composer.render();
        }
        
        // ==================== åŠ è½½çŠ¶æ€ç®¡ç† ====================
        function updateLoadingStatus(message, progress) {
            document.getElementById('systemStatus').textContent = message;
            document.getElementById('loadingDetails').textContent = message;
            
            if (progress !== undefined) {
                document.getElementById('progressFill').style.width = `${progress}%`;
            }
        }
        
        function updateLoadingDetails(details) {
            document.getElementById('loadingDetails').textContent = details;
        }
        
        function updatePhotoLoadingProgress(loadedCount) {
            document.getElementById('loadedPhotos').textContent = loadedCount;
            document.getElementById('counterNumber').textContent = loadedCount;
            
            const progress = Math.floor((loadedCount / CONFIG.photoConfig.maxPhotos) * 100);
            updateLoadingStatus(`åŠ è½½å›¾ç‰‡ä¸­... ${loadedCount}/${CONFIG.photoConfig.maxPhotos}`, 80 + (progress * 0.15));
        }
        
        function completeLoading() {
            document.getElementById('loadingScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                updateSystemStatus('ç³»ç»Ÿå°±ç»ª');
                
                // æ˜¾ç¤ºç…§ç‰‡è®¡æ•°å™¨
                document.getElementById('photoCounter').style.display = 'block';
            }, 800);
        }
        
        function updateSystemStatus(status) {
            document.getElementById('systemStatus').textContent = status;
        }
        
        // ==================== åˆå§‹åŒ–å¯åŠ¨ ====================
        window.addEventListener('DOMContentLoaded', () => {
            // è®¾ç½®åˆå§‹åŠ è½½çŠ¶æ€
            updateLoadingStatus('å‡†å¤‡å¯åŠ¨3Dæ¸²æŸ“å¼•æ“...', 5);
            
            // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿æ‰€æœ‰èµ„æºåŠ è½½
            setTimeout(() => {
                try {
                    init();
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                    updateLoadingStatus('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 100);
                    document.getElementById('loadingDetails').textContent = `é”™è¯¯: ${error.message}`;
                }
            }, 500);
        });
    </script>
</body>
</html>
